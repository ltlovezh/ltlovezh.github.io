<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="风之谷">
<meta property="og:url" content="http://ltlovezh.github.io/index.html">
<meta property="og:site_name" content="风之谷">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风之谷">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6226090551544907000,
      author: '博主'
    }
  };
</script>

  <title> 风之谷 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3eb4a2a3d5caf7e808ca7df210442e1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=55452216";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">风之谷</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">你必须非常努力,才能看起来毫不费力</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/29/Kotlin-Type-safe-Builders及性能对比/" itemprop="url">
                  Kotlin : Type-safe Builders及性能对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-29T22:39:38+08:00" content="2016-04-29">
              2016-04-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/29/Kotlin-Type-safe-Builders及性能对比/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/29/Kotlin-Type-safe-Builders及性能对比/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/29/Kotlin-Type-safe-Builders及性能对比/" class="leancloud_visitors" data-flag-title="Kotlin : Type-safe Builders及性能对比">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文承接上文<a href="http://ltlovezh.com/2016/04/27/Kotlin%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%952/" target="_blank" rel="external">Kotlin基本语法2</a>，主要介绍扩展函数、Type-safe Builders以及使用Kotlin开发Android带来的安装包和方法数增量。</p>
<h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><p>在Kotlin中，我们可以在不继承类的基础上，对某个类添加函数和属性，即扩展函数和扩展属性。</p>
<h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>扩展函数基本格式：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> 被扩展类.扩展函数<span class="params">(函数参数...)</span> : 返回类型&#123;</span></span><br><span class="line"><span class="comment">//代码块内，可以访问被扩展类的成员属性和函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我感觉扩展函数最大的特色就是可以访问被扩展类的成员属性和函数，这点太方便了。看个官网的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int, index2: Int</span>)</span> &#123;</span></span><br><span class="line">    <span class="comment">// 'this' corresponds to the list</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> tmp</span> = this[index1] </span><br><span class="line">    this[index1] = this[index2]</span><br><span class="line">    this[index2] = tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用:</span><br><span class="line"><span class="variable"><span class="keyword">var</span> mList</span> = mutableListOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">mList.swap(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">println(mList)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>关于扩展函数有几点需要说明：</p>
<ol>
<li>扩展函数是静态解析的，不是虚函数，即不能被重写。</li>
<li>当类的成员函数和扩展函数有相同函数签名时，成员函数会优先被调用。</li>
</ol>
<h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>扩展属性基本格式：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> 被扩展类.扩展属性</span> : 扩展属性类型</span><br><span class="line">    <span class="keyword">set</span>(value)</span><br><span class="line">    <span class="keyword">get</span>()</span><br></pre></td></tr></table></figure></p>
<p>实际上，扩展属性并没有真正的在类中新增属性，所以扩展属性没有<code>field</code>字段，即不能为扩展属性设置初始值。一般情况下，只能重写<code>set</code>和<code>get</code>方法，为扩展属性提供操作。看个官网的例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> &lt;T&gt; MutableList&lt;T&gt;.lastIndex</span>: <span class="keyword">Int</span></span><br><span class="line">  <span class="keyword">get</span>() = size - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">调用：  </span><br><span class="line"><span class="variable"><span class="keyword">var</span> mList</span> = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(mList.lastIndex)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Type-safe-Builders"><a href="#Type-safe-Builders" class="headerlink" title="Type-safe Builders"></a>Type-safe Builders</h2><p>个人感觉<code>Type-safe Builders</code>是kotlin中的一大特色。它让我们以陈述式语言风格来创建对象。非常适合于创建多级嵌套的数据结构，例如：XML文件、布局文件等。其语法类似于gradle，都是基于DSL构建。</p>
<p><code>Type-safe Builders</code>之所以能够成行，很大程度上依赖于扩展函数、扩展属性和<code>Lambda With Receiver</code>。关于Lambda With Receiver，可以参考上一篇文章。</p>
<p>下面看一个例子，假如我们要创建任意Android View，若通过java代码来写，那么每个View都是不同的，需要每个View单独来写。但是在Kotlin中，我们可以结合泛型、扩展函数和<code>Lambda With Receiver</code>，实现一个通用的函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对Context的扩展函数，创建任意View，并使用init函数对View进行初始化</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : View&gt;</span> Context.<span class="title">createView</span><span class="params">(init: <span class="type">T.(</span>)</span> -&gt; <span class="keyword">Unit</span>): T &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> construct</span> = T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">getConstructor</span></span>(Context::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> mView</span> = construct.newInstance(this)</span><br><span class="line">    mView.init()</span><br><span class="line">    <span class="keyword">return</span> mView</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要在Activity中调用,创建一个Button</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> mButton</span> = createView<span class="type">&lt;Button&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//这里实际调用了Button.setText方法</span></span><br><span class="line">            text = <span class="string">"Click Me"</span> </span><br><span class="line">            <span class="comment">//这里实际调用了Button.setTextSize方法</span></span><br><span class="line">            textSize = <span class="number">20</span>f</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//需要在Activity中调用,创建一个TextView</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> mTextView</span> = createView<span class="type">&lt;TextView&gt;</span> &#123;</span><br><span class="line">            text = <span class="string">"Hello World"</span></span><br><span class="line">            textSize = <span class="number">20</span>f</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上面针对Context创建了一个扩展函数createView，参数类型是<code>T.() -&gt; Unit</code>，即一种Lambda With Receiver，这里Receiver就是泛型T。接着在函数体内根据反射创建了具体的泛型对象（必须是View的子类），然后调用参数函数对泛型对象进行初始化。最后，使用该函数，分别创建了Button和TextView。</p>
<p>理论上，通过createView函数，我们可以创建任意View对象，并且可以针对不同对象指定不同的初始化操作。</p>
<p>实现createView函数有一个很重要的条件，那就是根据泛型类型T，创建对应的对象（在java里，打死也做不到）。这要求函数必须是<code>inline</code>的，且T必须是<code>reified</code>具体化的。这样，函数在调用时就会内联到函数调用处，此时T的类型实际上是确定的，因而Kotlin通过reified关键字告诉编译器，T可以当实际类型来使用。</p>
<p>OK，上面实现了第一步，可以创建任意View了。但是还无法创建层级关系。下面我们再来一个扩展函数，搞定层级关系：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对ViewGroup的扩展函数，创建任意子View，并使用init函数对子View进行初始化，同时把子View添加到Receiver表示的父View当中。</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : View&gt;</span> ViewGroup.<span class="title">createView</span><span class="params">(init: <span class="type">T.(</span>)</span> -&gt; <span class="keyword">Unit</span>): TV &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> construct</span> = T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">getConstructor</span></span>(Context::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> mView</span> = construct.newInstance(context)</span><br><span class="line">    addView(mView)</span><br><span class="line">    mView.init()</span><br><span class="line">    <span class="keyword">return</span> mView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面对ViewGroup定义了扩展函数createView。在createView内部可以访问ViewGroup的成员函数和属性，这里通过addView把创建出来的子View添加到了父View中，实现了层级的关联。</p>
<p>假如我们要用kotlin实现下面的View布局：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">&lt;LinearLayout</span><br><span class="line">    android:layout_width="wrap_content"</span><br><span class="line">    android:layout_height="wrap_content"</span><br><span class="line">    android:orientation="horizontal"&gt;</span></span><br><span class="line">        <span class="type">&lt;Button</span><br><span class="line">            android:layout_width="wrap_content"</span><br><span class="line">            android:layout_height="wrap_content"</span><br><span class="line">            android:layout_weight="1"</span><br><span class="line">            android:text="first Button"</span><br><span class="line">            android:textSize="20px" /&gt;</span></span><br><span class="line">        <span class="type">&lt;TextView</span><br><span class="line">            android:layout_width="wrap_content"</span><br><span class="line">            android:layout_height="wrap_content"</span><br><span class="line">            android:layout_weight="1"</span><br><span class="line">            android:text="second TextView"</span><br><span class="line">            android:textSize="20px" /&gt;</span></span><br><span class="line"><span class="type">&lt;/LinearLayout&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>利用之前提供的两个createView函数，来实现上述布局，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">createView<span class="type">&lt;LinearLayout&gt;</span> &#123;</span><br><span class="line">    orientation = LinearLayout.HORIZONTAL</span><br><span class="line">    <span class="comment">//添加第一个子View</span></span><br><span class="line">    createView<span class="type">&lt;Button&gt;</span> &#123;</span><br><span class="line">        with(layoutParams <span class="keyword">as</span> LinearLayout.LayoutParams) &#123;</span><br><span class="line">            width = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">            height = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">            weight = <span class="number">1</span>f</span><br><span class="line">            &#125;</span><br><span class="line">        textSize = <span class="number">20</span>f</span><br><span class="line">        text = <span class="string">"first Button"</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//添加第二个子View</span></span><br><span class="line">    createView<span class="type">&lt;TextView&gt;</span> &#123;</span><br><span class="line">        with(layoutParams <span class="keyword">as</span> LinearLayout.LayoutParams) &#123;</span><br><span class="line">            width = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">            height = ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">            weight = <span class="number">1</span>f</span><br><span class="line">            &#125;</span><br><span class="line">        textSize = <span class="number">20</span>f</span><br><span class="line">        text = <span class="string">"second TextView"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最外层的createView函数是Context的扩展函数，他的函数参数是<code>LinearLayout.() -&gt; Unit</code>，所以最外层大括号内的Receiver就是LinearLayout对象。<br>因此内层的createView函数是ViewGroup的扩展函数，这样内部创建的Button和TextView都添加到了LinearLayout中，实现了层级关联。</p>
<p>上面的代码已经很简洁了，但是还有提升的空间（这里一开始我也没有想到，是<a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112113&amp;idx=1&amp;sn=e7e3cffe60150e7db20ebd4f648b4c15&amp;scene=23&amp;srcid=04279tiwca4UACLXtISl5ktd#rd" target="_blank" rel="external">参考的这篇文章</a>）。</p>
<p>上述构建方式主要缺点是还要指定泛型参数，下面我们就把泛型参数干掉。首先，需要根据View类型为Context和ViewGroup声明扩展函数，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的三个函数调用的都是Context的扩展函数createView，因此创建出来的都是单个View。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">linearLayout</span><span class="params">(init: <span class="type">LinearLayout.(</span>)</span> -&gt; <span class="keyword">Unit</span>) = <span class="title">createView</span><span class="params">(init)</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">textView</span><span class="params">(init: <span class="type">TextView.(</span>)</span> -&gt; <span class="keyword">Unit</span>) = <span class="title">createView</span><span class="params">(init)</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Context.<span class="title">button</span><span class="params">(init: <span class="type">TextView.(</span>)</span> -&gt; <span class="keyword">Unit</span>) = <span class="title">createView</span><span class="params">(init)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的三个函数调用的都是ViewGroup的扩展函数createView，因此创建出来的View都会被添加到付ViewGroup中。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ViewGroup.<span class="title">linearLayout</span><span class="params">(init: <span class="type">LinearLayout.(</span>)</span> -&gt; <span class="keyword">Unit</span>) = <span class="title">createView</span><span class="params">(init)</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ViewGroup.<span class="title">textView</span><span class="params">(init: <span class="type">TextView.(</span>)</span> -&gt; <span class="keyword">Unit</span>) = <span class="title">createView</span><span class="params">(init)</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ViewGroup.<span class="title">button</span><span class="params">(init: <span class="type">TextView.(</span>)</span> -&gt; <span class="keyword">Unit</span>) = <span class="title">createView</span><span class="params">(init)</span></span></span><br></pre></td></tr></table></figure></p>
<p>因为上述扩展函数，不再有泛型，而且都是单个函数参数，因此新的构建方式可以简化如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Context.linearLayout函数</span></span><br><span class="line">linearLayout &#123;</span><br><span class="line">    orientation = LinearLayout.HORIZONTAL</span><br><span class="line">    <span class="comment">//调用ViewGroup.button函数</span></span><br><span class="line">    button &#123;</span><br><span class="line">        with(layoutParams <span class="keyword">as</span> LinearLayout.LayoutParams) &#123;</span><br><span class="line">            weight = <span class="number">1</span>f</span><br><span class="line">            &#125;</span><br><span class="line">        textSize = <span class="number">20</span>f</span><br><span class="line">        text = <span class="string">"first Button"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用ViewGroup.textView函数</span></span><br><span class="line">    textView &#123;</span><br><span class="line">        with(layoutParams <span class="keyword">as</span> LinearLayout.LayoutParams) &#123;</span><br><span class="line">            weight = <span class="number">1</span>f</span><br><span class="line">            &#125;</span><br><span class="line">        textSize = <span class="number">20</span>f</span><br><span class="line">        text = <span class="string">"second TextView"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎样，上述方式是不是很像Gradle配置文件，都是基于DSL的，差不太多。</p>
<p>这种基于<code>Type-safe Builders</code>构建View层级的方式相对于Java Code来说确实简洁不少。<br>但是在Android中，我们一般通过XML文件来进行View布局，这种方式非常直观。但使用XML布局文件也存在着性能问题，因为系统需要先解析XML文件，再去构建View对象。</p>
<p>下面我们简单对比下通过<code>Type-safe Builders</code>形式代码和XML文件实现相同布局的耗时。这里的对比方案是使用Github上的项目<a href="https://github.com/CodingDoug/kotlin-view-builder" target="_blank" rel="external">kotlin-view-builder</a>，详细过程可以看下代码。</p>
<p>简单来说，一种是通过上面介绍的<code>Type-safe Builders</code>方式构建View对象,另一种是通过<code>LayoutInflater</code>来加载布局文件。最终要实现的布局如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span><br><span class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span><br><span class="line">    <span class="attr">android:paddingTop</span>=<span class="string">"8dp"</span></span><br><span class="line">    <span class="attr">android:paddingBottom</span>=<span class="string">"8dp"</span></span><br><span class="line">    <span class="attr">android:paddingLeft</span>=<span class="string">"16dp"</span></span><br><span class="line">    <span class="attr">android:paddingRight</span>=<span class="string">"16dp"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="attr">android:layout_marginRight</span>=<span class="string">"16dp"</span></span><br><span class="line">        <span class="attr">android:layout_marginEnd</span>=<span class="string">"16dp"</span></span><br><span class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span><br><span class="line">        <span class="attr">android:textSize</span>=<span class="string">"24sp"</span></span><br><span class="line">        <span class="attr">android:text</span>=<span class="string">"@string/time"</span></span><br><span class="line">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span><br><span class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span><br><span class="line">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span><br><span class="line">        &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">            <span class="attr">android:text</span>=<span class="string">"@string/day"</span></span><br><span class="line">            /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span><br><span class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">            <span class="attr">android:text</span>=<span class="string">"@string/location"</span></span><br><span class="line">            /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>耗时结果如下表所示（单位：ms，取5次平均值，测试手机为小米4 Android6.0系统）：<br>| 创建View对象的次数| Type-safe Builders | XML |XML / Builders |<br>| :——–: | :—–: | :—-: | :—-: |<br>| 1 | 2 | 4 | 2.0 |<br>| 10 | 20 | 35 | 1.75 |<br>| 100 | 189 | 284 | 1.50 |<br>| 500 | 968 | 1402 | 1.44 |<br>| 1000 | 1945 | 2681 | 1.38 |</p>
<p>由上表可知：通过代码构建View对象总体上还是要比XML快一些。但是随着View对象增多，kotlin的优势逐渐变小（这点还没有想明白）。<br>除了上述性能对比，其实这两种方式各有其使用场景，具体可以参考<br><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112113&amp;idx=1&amp;sn=e7e3cffe60150e7db20ebd4f648b4c15&amp;scene=23&amp;srcid=04279tiwca4UACLXtISl5ktd#rd" target="_blank" rel="external">实战kotlin@android（三）：扩展变量与其它技巧</a></p>
<h2 id="方法数和安装包"><a href="#方法数和安装包" class="headerlink" title="方法数和安装包"></a>方法数和安装包</h2><p>在Android开发中，方法数和安装包是永恒的话题。因此我们看下添加kotlin后的安装包和方法数增量。</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">安装包</th>
<th style="text-align:center">方法数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">新建的Android项目</td>
<td style="text-align:center">1.2M</td>
<td style="text-align:center">16259</td>
</tr>
<tr>
<td style="text-align:center">新增Stdlib和Runtime类库</td>
<td style="text-align:center">1.5M</td>
<td style="text-align:center">23177</td>
</tr>
<tr>
<td style="text-align:center">新增Reflect类库</td>
<td style="text-align:center">2.1M</td>
<td style="text-align:center">34855</td>
</tr>
<tr>
<td style="text-align:center">新增Anko类库</td>
<td style="text-align:center">2.2M</td>
<td style="text-align:center">36971</td>
</tr>
</tbody>
</table>
<p>Stdlib和Runtime是Kotlin必不可少的基础类库，方法数大概是7000个，还可以接受。<br>相对来说，Reflect类库的安装包和方法数增量都比较大，但是该类库不是必须的，可以选择使用(主要是为了处理kotlin反射和java反射之间的兼容性)。最后一个Anko是为了方便构建动态View层级，可视情况决定是否采用。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/Matrix使用解析/" itemprop="url">
                  Matrix使用解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T19:43:06+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/Matrix使用解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/Matrix使用解析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/27/Matrix使用解析/" class="leancloud_visitors" data-flag-title="Matrix使用解析">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Matrix的使用范围非常广泛，我们平时使用的Tween Animation，其在进行位移、缩放、旋转时，都是通过Matrix来实现的。除此之外，在进行图像变换操作时，Matrix也是最佳选择。</p>
<p>Matrix是一个3*3的矩阵，如图所示：<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/matrix.png" alt="Matrix"></p>
<p>我们可以直接通过<code>Matrix.getValues</code>方法获取Matrix的矩阵值（浮点型数组类型），然后修改矩阵值（Matrix类为每一个矩阵值提供了固定索引，如：MSCALE_X、MSKEW_X等），最后通过<code>Matrix.setValues</code>方法重新设置Matrix值，已达到修改Matrix的目的。这种方式要求我们对Matrix每一个值的作用都要十分了解，操作起来比较繁琐，但却是最灵活、最彻底的操作方式。</p>
<p>具体要修改哪些Matrix值，则取决于要实现什么效果，从本质上这是一个数学问题，这里给出几种比较常见的方案：</p>
<ol>
<li><p>实现Translate操作<br>位移操作在Matrix中对应是<code>MTRANS_X</code>和<code>MTRANS_Y</code>值，分别表示X和Y轴上的位移量，假设在X和Y轴上分别位移100px，那么对应的Matrix就是<img src="http://7xs2qy.com1.z0.glb.clouddn.com/translate.png" alt="tranlate"></p>
</li>
<li><p>实现Scale操作<br>缩放操作在Matrix中对应的是<code>MSCALE_X</code>和<code>MSCALE_Y</code>值，分别表示X和Y轴上的缩放比例，假设在X和Y轴上分别放大2倍，那么对应的Matrix就是<img src="http://7xs2qy.com1.z0.glb.clouddn.com/scale.png" alt="scale"></p>
</li>
<li><p>实现Rotate操作<br>旋转操作在Matrix中对应是<code>MSCALE_X</code>、<code>MSCALE_Y</code>、<code>MSKEW_X</code>和<code>MSKEW_Y</code>值，假设我们要以坐标原点为中心，旋转A度，那么对应的Matrix就是<img src="http://7xs2qy.com1.z0.glb.clouddn.com/rotate.png" alt="rotate"></p>
</li>
<li><p>实现Skew操作<br>错切操作在Matrix中对应的是<code>MSKEW_X</code>和<code>MSKEW_Y</code>，分别表示X和Y轴上的错切系数，假设在X轴上错切系数为0.5，Y轴上为2，那么对应的Matrix就是<img src="http://7xs2qy.com1.z0.glb.clouddn.com/skew.png" alt="skew"><br>其他3种操作都比较常见，但是错切操作我们可能不是很熟悉。</p>
<blockquote>
<p>错切可分为水平错切和垂直错切。<br>水平错切表示变换后，Y坐标不变，X坐标则按比例发生平移，且平移的大小和Y坐标成正比，即新的坐标为<code>(X+Matrix[MSKEW_X] * Y,Y)</code>。<br>垂直错切表示变换后，X坐标不变，Y坐标则按比例发生平移，且平移的大小和X坐标成正比，即新的坐标为<code>(X,Y+Matrix[MSKEW_Y] * X)</code>。<br>当然，我们也可以同时实现水平错切和垂直错切。</p>
</blockquote>
</li>
</ol>
<p>关于为什么修改Matrix的这些值后，就实现了位移、缩放、旋转和错切操作，就主要是数学推导过程了，可以参考这篇文章—— <a href="http://blog.csdn.net/pathuang68/article/details/6991867" target="_blank" rel="external">Android中图像变换Matrix的原理</a>，讲解的非常详细，强烈推荐。</p>
<p>除了可以直接修改Matrix值，Matrix类还提供了一些API来操作Matrix。这里主要介绍几类比较常用的API。</p>
<h2 id="setXXX、preXXX和postXXX"><a href="#setXXX、preXXX和postXXX" class="headerlink" title="setXXX、preXXX和postXXX"></a><code>setXXX</code>、<code>preXXX</code>和<code>postXXX</code></h2><p>XXX可以是Translate、Rotate、Scale、Skew和Concat(表示直接操作Matrix矩阵)。我们主要搞清楚这3种API的区别就OK了。</p>
<ol>
<li><code>setXXX</code>，首先会将该Matrix设置为单位矩阵，即相当于调用reset()方法，然后再设置该Matrix的值。</li>
<li><code>preXXX</code>，不会重置Matrix，而是被当前Matrix左乘（矩阵运算中，A左乘B等于A <em> B），即M’ = M </em> S(XXX)。</li>
<li><code>postXXX</code>，不会重置Matrix，而是被当前Matrix右乘（矩阵运算中，A右乘B等于B <em> A），即M’ = S(XXX) </em> M。</li>
</ol>
<p>当这些API同时使用时，又会出现什么效果那，我们来看个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line"><span class="keyword">float</span>[] points = <span class="keyword">new</span> <span class="keyword">float</span>[] &#123; <span class="number">10.0f</span>, <span class="number">10.0f</span> &#125;;</span><br><span class="line">matrix.postScale(<span class="number">2.0f</span>, <span class="number">3.0f</span>);<span class="comment">// 第1步</span></span><br><span class="line">matrix.preRotate(<span class="number">90</span>);<span class="comment">// 第2步</span></span><br><span class="line">matrix.setScale(<span class="number">2f</span>, <span class="number">3f</span>);<span class="comment">// 第3步</span></span><br><span class="line">matrix.preTranslate(<span class="number">8.0f</span>, <span class="number">7.0f</span>);<span class="comment">// 第5步</span></span><br><span class="line">matrix.postTranslate(<span class="number">18.0f</span>, <span class="number">17.0f</span>);<span class="comment">// 第4步</span></span><br><span class="line">matrix.mapPoints(points);</span><br><span class="line">Log.i(<span class="string">"test"</span>, points[<span class="number">0</span>] + <span class="string">" : "</span> + points[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p>
<p>最后得到的结果是：<code>54.0 : 68.0</code><br>可以发现，在第3步setScale之前的第1、2步根本就没有用，直接被第3步setScale覆盖了。所以最终的矩阵运算为 </p>
<blockquote>
<p><code>Translate(18,17) * Scale(2,3) * Translate(8,7) * (10,10)</code></p>
</blockquote>
<p>这样，就很容易得出最后的结果了。</p>
<p>这里也许会有一个疑问，为什么坐标点(10,10)会被结果矩阵（矩阵运算虽然不满足交换律，但是满足结合律）左乘，而不是右乘。这一点我们看一下下面的矩阵运算就会明白。<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/MatrixMul.png" alt="Matrix相乘"><br>等号左边是变换后的坐标点，等号右边是Matrix矩阵左乘原始坐标点。因为Matrix是3行3列，坐标点是3行1列，所以正好可以相乘，但如果反过来，就不满足矩阵相乘的条件了（<code>左边矩阵的列数等于右边矩阵的行数</code>）。所以，就可以理解为什么是结果矩阵左乘原始坐标点了。</p>
<p>也正因为这一点以及矩阵的结合律，所以我们可以理解上面矩阵运算的流程：</p>
<blockquote>
<p><strong><em>先对原始坐标点(10,10)进行Translate(8,7)位移，然后再对中间坐标点(18,17)进行Scale(2,3)放大，最后再次对中间坐标点(36,51)进行Translate(18,17)操作，就得到了最后的坐标点(54,68)</em></strong>。</p>
</blockquote>
<p><strong>这里还有一个小Tips</strong>：<br>当需要对Matrix矩阵进行比较复杂的设置时，可以把这些复杂的设置，拆分为多个步骤，每一个步骤都是一个简单的Matrix，然后再依据这些步骤的先后顺序，决定是通过左乘 or 右乘得到结果矩阵，最后通过结果矩阵左乘原始坐标就OK了（设计时，可以拆分之后理解，但最终运算时还是要得到一个结果矩阵，再去操作原始坐标）。</p>
<p> 还有一点需要了解：Canvas里的scale、translate、rotate和concat都是preXXX方法，如果要进行更多的变换可以先从Canvas获得Matrix, 变换后再设置回Canvas. <strong>但是这里有个坑，最后会进行介绍</strong>。   <a href="#jump">点击这里跳转</a></p>
<h2 id="mapPoints-mapRect-mapVectors"><a href="#mapPoints-mapRect-mapVectors" class="headerlink" title="mapPoints mapRect  mapVectors"></a><code>mapPoints</code> <code>mapRect</code>  <code>mapVectors</code></h2><p>这些API很简单，主要是根据当前Matrix矩阵对点、矩形区域和向量进行变换，以得到变换后的点、矩形区域和向量。经常和下面的<code>invert</code>方法结合使用。</p>
<h2 id="invert"><a href="#invert" class="headerlink" title="invert"></a><code>invert</code></h2><p>通过上面的mapXXX方法，可以获取变换后的坐标或者矩形。但假设我们知道了变换后的坐标，如何计算Matrix变换前的坐标那？！<br>此时通过<code>invert</code>方法获取的逆矩阵就派上用场了。所谓逆矩阵，就是Matrix旋转了30度，逆Matrix就反向旋转30度，Matrix放大n倍，逆Matrix就缩小n倍。假设逆矩阵是invertMatrix，那么Matrix.preConcat(invertMatrix) 和 Matrix.postConcat(invertMatrix) 都应该等于单位矩阵（但实际上会有一些误差）。<br>所以，通过Matrix和invertMatrix对坐标进行变换的规则可总结如下：<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/invertMatrix.png" alt="通过Matrix和invertMatrix对坐标进行变换的规则"></p>
<p><strong>逆矩阵</strong>在进行自定义View Touch事件处理时很有用，假设我们在自定义View中，通过Matrix（包含了旋转、缩放和位移操作）绘制了Bitmap，现在想要判断Touch事件是否在变换后的Bitmap范围内，应该如何操作那？！<br>首先想到的可能是下面的方案：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RectF rect = <span class="keyword">new</span> RectF(bitmap.getWidth(),bitmap.getHeight());</span><br><span class="line"><span class="comment">//假设matrix就是对bitmap进行变换的矩阵</span></span><br><span class="line">matrix.mapRect(rect);</span><br><span class="line"><span class="keyword">boolean</span> isTouchBitmap = rect.contains(touchX,touchY);</span><br></pre></td></tr></table></figure></p>
<p>但是这种方式实际上不是非常的准确，通过matrix变换后的矩形区域并不是真实的Bitmap区域，而是包含bitmap的矩形区域（很难描述啊），看下图就知道了：<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/Matrix%E6%AD%A3%E5%90%91.png" alt="Matrix正向操作"><br>图中的绿色矩形区域就是我们进行判断的rect区域，很明显误差很大哈。既然正向操作不可行，那就只能试下逆向操作了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RectF rect = <span class="keyword">new</span> RectF(bitmap.getWidth(),bitmap.getHeight());</span><br><span class="line"><span class="keyword">float</span> eventFloat[] = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;touchX,touchY&#125;;</span><br><span class="line"><span class="comment">//假设invertMatrix是matrix的逆矩阵,这里对Touch坐标进行逆向操作。</span></span><br><span class="line">invertMatrix.mapPoints(eventFloat);</span><br><span class="line"><span class="keyword">boolean</span> isTouchBitmap = rect.contains(eventFloat[<span class="number">0</span>],eventFloat[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p>
<p>通过这种方式，首先会对Touch坐标进行逆矩阵操作，然后再判断是否落在原始bitmap矩形区域内（上图中的小企鹅），就比较精确了。精妙哈！！！</p>
<hr>
<p><span id="jump"></span></p>
<h2 id="Canvas-getMatrix的坑"><a href="#Canvas-getMatrix的坑" class="headerlink" title="Canvas.getMatrix的坑"></a><code>Canvas.getMatrix</code>的坑</h2><p>通过Canvas获取Matrix矩阵的拷贝，从API16开始，不再推荐使用。至于原因，可参考Google的解释<a href="https://code.google.com/p/android/issues/detail?id=24517" target="_blank" rel="external">Issue 24517:    Canvas getMatrix/setMatrix with hardware acceleration bug</a>，里面提供了示例代码。</p>
<p>主要原因是，在开启硬件加速的情况下，<code>Canvas.getMatrix</code> 获取的矩阵是相对于Canvas所属View的，而<code>Canvas.setMatrix</code> 则会把所设置的矩阵当做相对于整个屏幕（包括系统栏）。</p>
<p>所谓相对于某个View，就是说不管这个View在屏幕中的任何位置，通过这个View的Canvas获取的Matrix的X和Y位移都是0，也就是Matrix在当前View的本地坐标系中，和View的left和top值无关。</p>
<p>所谓相对于整个屏幕，也就很好理解了，即获取的Matrix是在整个屏幕表示的世界坐标系中的，一般情况下，获取的矩阵的X位移为view.left值，Y位移为系统栏的高度 + view.top值。并且后续对Canvas的变换操作都是基于这个初始矩阵进行的。</p>
<p>所以在硬件加速的情况下，调用<code>canvas.setMatrix(canvas.getMatrix())</code>后，就会导致View默认从屏幕左上角（包含了系统栏）开始绘制，这样就会有一部分内容被系统栏遮挡住。<br>这里对Google提供的示例代码进行了简化，就是把一个自定义View添加到带有系统栏的Activity中，自定义View的onDraw方法如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">   canvas.save(Canvas.MATRIX_SAVE_FLAG);</span><br><span class="line">   Matrix matrix = canvas.getMatrix();</span><br><span class="line">   <span class="comment">//查看获取的初始Matrix</span></span><br><span class="line">   Log.i(<span class="string">"matrix"</span>,matrix.toString());</span><br><span class="line">   <span class="comment">// This line changes the canvas' transformation when hardware acceleration is turned on (but shouldn't)</span></span><br><span class="line">   canvas.setMatrix(matrix);</span><br><span class="line">        </span><br><span class="line">   mPaint.setColor(Color.GREEN);</span><br><span class="line">   <span class="comment">//draw一个200*200的矩形区域</span></span><br><span class="line">   canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, mPaint);</span><br><span class="line">   canvas.restore();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// here the bottom right corner of the green rectangle should lie(but doesn't)</span></span><br><span class="line">   mPaint.setColor(Color.RED);</span><br><span class="line">   canvas.drawPoint(<span class="number">210</span>, <span class="number">210</span>, mPaint);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在没有开启硬件加速的情况下，矩形区域和红点显示正常，<br>Canvas.getMatrix方法获取的Matrix也是在屏幕世界坐标系中的，即<code>Matrix{[1.0, 0.0, 0.0][0.0, 1.0, 60.0][0.0, 0.0, 1.0]}</code>，其中Y轴位移为60，表示的就是状态栏的高度。这样重新setMatrix之后，就不会出现问题，如图所示：<img src="http://7xs2qy.com1.z0.glb.clouddn.com/nothardwareAcceleration.png" alt="关闭硬件加速"></p>
<p>但是在开启硬件加速的情况下，矩形区域有一部分被系统栏遮挡住了，可以对比下红点的位置就就知道了，同时获取的Matrix也是相对于当前View本地坐标系的，即<code>Matrix{[1.0, 0.0, 0.0][0.0, 1.0, 0.0][0.0, 0.0, 1.0]}</code>，没有产生任何位移。这样重新setMatrix之后，就会出现问题（因为对Matrix的理解不同），如图所示：<img src="http://7xs2qy.com1.z0.glb.clouddn.com/hardwareAcceleration.png" alt="开启硬件加速"></p>
<p>既然，<code>Canvas.getMatrix</code>被废弃了，那有什么替换的方法嘛？！这里Google并没有明确的指出。但是我觉得有两种方式可以实现类似功能。</p>
<ol>
<li>不获取Matrix，直接通过Canvas提供的位移、旋转、缩放等API来实现类似功能。</li>
<li>从API11开始，提供了View Properties，可以直接对View进行位移、旋转、缩放等操作，同时也提供了<code>View.getMatrix</code>方法来获取当前View的Matrix（也算是Canvas.getMatrix的替代方案了）。当然，这个Matrix也是相对于View本身本地坐标系的。</li>
</ol>
<hr>
<p>本文简单介绍了Matrix的基本使用方法，关于Matrix的底层原理，还没有涉猎，后续深入研究后，再补充进来。</p>
<p>最后推荐几篇比较好的Matrix相关的文章。</p>
<ol>
<li><a href="http://blog.csdn.net/pathuang68/article/details/6991867" target="_blank" rel="external">Android中图像变换Matrix的原理、代码验证和应用(一)</a></li>
<li><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/47984915" target="_blank" rel="external">Android中图像变换Matrix的原理、代码验证和应用(二)</a></li>
<li><a href="http://blog.csdn.net/pathuang68/article/details/6992085" target="_blank" rel="external"> Android中图像变换Matrix的原理、代码验证和应用(三)</a></li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/Android动画框架三/" itemprop="url">
                  Android动画框架三
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T17:54:58+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/Android动画框架三/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/Android动画框架三/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/27/Android动画框架三/" class="leancloud_visitors" data-flag-title="Android动画框架三">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇接Android动画框架二,前两篇文章主要介绍了Frame Animation、Tween Animation和Property Animator的使用方式和实现机制。本篇主要学习下Android中布局动画的使用和实现机制。其中，不管是哪种动画的实现机制，最终都会和Choreographer关联起来。关于Choreographer机制，网上有一篇文章讲解的很详细，本文就不再赘述。</p>
<h2 id="Choreographer机制"><a href="#Choreographer机制" class="headerlink" title="Choreographer机制"></a>Choreographer机制</h2><p>Google在Android4.1上增加了Choreographer机制，用于和Vsync机制配合，实现对用户输入、动画以及布局和绘图的控制。关于Choreographer机制的详细实现，可以参考<a href="http://blog.csdn.net/yangwen123/article/details/39518923" target="_blank" rel="external">Android系统Choreographer机制实现过程</a>。</p>
<p>Choreographer机制对外的接口就是它的各种postCallbackXX和postFrameCallbackXX方法，在源码中搜下这几个方法的调用，就可以知道哪里使用了Choreographer机制。其中有我们比较熟悉的：</p>
<ul>
<li>View.scheduleTraversals方法，实现View的绘制流程（也实现了Tween Animation）；</li>
<li>ValueAnimator.AnimationHandler.scheduleAnimation方法，实现Property Animator；</li>
<li>View.scheduleDrawable方法，实现Frame Animation；</li>
<li>View.postOnAnimation和View.postOnAnimationDelayed方法，实现自定义的动画。</li>
</ul>
<p>其他的调用，此处不再赘述。</p>
<h2 id="布局动画"><a href="#布局动画" class="headerlink" title="布局动画"></a>布局动画</h2><p>布局动画是指ViewGroup在布局时产生的动画效果。</p>
<h3 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h3><p>LayoutTransition表示对ViewGroup中的子View进行动画显示，一般用在对ViewGroup添加、删除、隐藏、显示子View时添加过渡动画，避免僵硬的显示过程。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>需要明确一点：LayoutTransition是设置给ViewGroup对象的，而非它的子View。<br>当一个ViewGroup发生以下情况时，会对子View产生动画效果：</p>
<ul>
<li>在ViewGroup中显示地添加一个子元素</li>
<li>在ViewGroup中显示地删除一个子元素</li>
<li>通过View.setVisibility()改变View的可见性</li>
<li>ViewGroup的布局发生改变时</li>
</ul>
<p>因此，LayoutTransition包含5种类型的过渡动画：</p>
<ol>
<li>APPEARING，当一个子View显示在ViewGroup中时，对该子View设置的动画类型。</li>
<li>CHANGE_APPEARING，当一个子View显示在ViewGroup中时，对被该子View影响的其他子View设置的动画类型。</li>
<li>DISAPPEARING，当一个子View消息在ViewGroup中时，对该子View设置的动画类型。</li>
<li>CHANGE_DISAPPEARING，当一个子View消失在ViewGroup中时，对被该子View影响的其他子View设置的动画类型。</li>
<li>CHANGE，除了子View出现或消失造成的对其他子View的布局影响之外，一些其他因素造成的对子View的布局影响，都属于该动画类型。</li>
</ol>
<p><strong><em> Tips：这里主要关注动画发生在哪些View身上。</em></strong></p>
<blockquote>
<p>默认情况下，DISAPPEARING、CHANGE_APPEARING和CHANGE动画是立即开始的，其他动画都有一个默认的开始延迟（默认是300ms）。这是因为，当一个新的View出现的时候，其他View要立即执行CHANGE_APPEARING动画腾出位置，而新出现的View在一定延迟之后再执行APPEARING出现；相反地，一个View消失的时候，它需要先执行DISAPPEARING动画消失，而其他的View需要先等它消失后再执行CHANGE_DISAPPEARING，占据空出的位置。（<font color="red">这里的逻辑可以参考LayoutTransition的构造函数来理解</font>）</p>
</blockquote>
<p>熟悉了LayoutTransition基本概念之后，我们看下如何使用布局动画，最简单的方式就是在布局资源文件中，添加<code>android:animateLayoutChanges=&quot;true&quot;</code>属性。这样，Android系统会帮我们设置默认的5种动画。<br>当然，我们也可以定制自己的动画，主要包括3步：</p>
<ol>
<li>首先，需要为不同过渡类型创建属性动画；</li>
<li>然后，通过<strong><em> LayoutTransition.setAnimator(int transitionType, Animator animator) </em></strong> 方法设置不同类型的属性动画；</li>
<li>最后，通过<strong><em> ViewGroup.setLayoutTransition </em></strong>方法，把我们定制的LayoutTransition设置到对应的ViewGroup当中。<br>这样，当ViewGroup发生布局改变时，就会自动触发对应类型的属性动画。</li>
</ol>
<p>关于LayoutTransition的具体案例，网上有很多资料，这里不再赘述，可以参考<a href="http://www.cnblogs.com/mengdd/p/3305973.html" target="_blank" rel="external">这里</a></p>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p>下面简单学习下LayoutTransition的实现机制：</p>
<p>既然LayoutTransition最终会设置到ViewGroup对象中，并且是在ViewGroup发生布局变化时触发相应的属性动画，那么我们就从ViewGroup添加子View开始分析。</p>
<p>通过阅读这部分代码，可知，ViewGroup.addView最终会调用到<strong>ViewGroup.addViewInner</strong>方法，而该方法，有如下逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">     mTransition.addChild(<span class="keyword">this</span>, child);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>即会调用我们设置的LayoutTransition的addChild方法，接下来会继续流转到<strong>LayoutTransition.addChild(ViewGroup parent, View child, boolean changesLayout)</strong>方法。该方法的关键代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//changesLayout表示是否会改变ViewGroup的布局。这里，若ViewGroup的布局发生改变，并且是CHANGE_APPEARING类型的动画，则调用runChangeTransition方法，改变其他子View的layout.也验证了上面添加子View时，会先触发CHANGE_APPEARING动画，为子View腾出位置的逻辑。若ViewGroup的布局不发生改变，则不触发Change动画。</span></span><br><span class="line"><span class="keyword">if</span> (changesLayout &amp;&amp; (mTransitionTypes &amp; FLAG_CHANGE_APPEARING) == FLAG_CHANGE_APPEARING) &#123;</span><br><span class="line">    runChangeTransition(parent, child, APPEARING);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mTransitionTypes &amp; FLAG_APPEARING) == FLAG_APPEARING) &#123;</span><br><span class="line">    <span class="comment">//为新的子View添加APPEARING动画</span></span><br><span class="line">    runAppearingTransition(parent, child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，来看下runAppearingTransition（负责<em>APPEARING</em>类型的动画）方法，该方法比较简单、直接:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝APPEARING属性动画，设置相关的参数</span></span><br><span class="line">Animator anim = mAppearingAnim.clone();</span><br><span class="line">anim.setTarget(child);</span><br><span class="line">anim.setStartDelay(mAppearingDelay);</span><br><span class="line">anim.setDuration(mAppearingDuration);</span><br><span class="line"><span class="comment">//设置插值器</span></span><br><span class="line"><span class="keyword">if</span> (mAppearingInterpolator != sAppearingInterpolator) &#123;</span><br><span class="line">    anim.setInterpolator(mAppearingInterpolator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (anim <span class="keyword">instanceof</span> ObjectAnimator) &#123;</span><br><span class="line">    ((ObjectAnimator) anim).setCurrentPlayTime(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里主要是添加监听器，处理动画结束时的通知</span></span><br><span class="line">anim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator anim)</span> </span>&#123;</span><br><span class="line">        currentAppearingAnimations.remove(child);</span><br><span class="line">        <span class="keyword">if</span> (hasListeners()) &#123;</span><br><span class="line">            ArrayList&lt;TransitionListener&gt; listeners =</span><br><span class="line">                    (ArrayList&lt;TransitionListener&gt;) mListeners.clone();</span><br><span class="line">            <span class="keyword">for</span> (TransitionListener listener : listeners) &#123;</span><br><span class="line">                listener.endTransition(LayoutTransition.<span class="keyword">this</span>, parent, child, APPEARING);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<p>然后，看下runChangeTransition（负责处理3种change事件）方法，该方法会处理<strong>APPEARING、DISAPPEARING和CHANGING</strong>3种类型的动画，基本逻辑是：</p>
<ol>
<li>根据不同的动画类型，选择相应的动画对象和动画持续时间。</li>
<li>通过setupChangeAnimation方法来处理所有子View的change动画</li>
<li>这一步主要是清理第二步中为不同子View添加的View.OnLayoutChangeListener监听器。（主要是清除那些布局没有发生变化的子View的监听器，布局发生变化的子View的监听器会在对应的Change动画结束后，被主动删除掉）</li>
</ol>
<p>其中，第二步是处理Change事件的关键，这里的代码比较长，但是并不复杂，</p>
<ol>
<li>获取对应类型的动画。 </li>
<li><p><font color="red">设置目标对象，从目标对象获取各个属性的初始值，<strong>作为动画的初始值</strong>。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Set the target object for the animation</span></span><br><span class="line"> anim.setTarget(child);</span><br><span class="line"><span class="comment">// A ObjectAnimator (or AnimatorSet of them) can extract start values from</span></span><br><span class="line"> <span class="comment">// its target object（从Target对象提取出初始值，这是子View的layout改变前的属性值）</span></span><br><span class="line"> anim.setupStartValues();</span><br></pre></td></tr></table></figure>
</li>
<li><p>为每个子View添加View.OnLayoutChangeListener监听器（该监听器只有在目标View的Layout改变之后，才会触发）。在该监听器里面会设置对应动画的持续时间和延迟时间，<font color="red">最重要的是要获取Layout改变后的各个属性值，<strong>作为动画的结束值</strong>，从这里可以看出，对于Change动画来说，之前设置的各个属性的开始值和结束值是没有意义的，在这里都会被替换成真实的开始值和结束值！！！</font></p>
</li>
<li>把当前LayoutTransition对象添加到ViewRootImpl.mPendingTransitions队列中（ViewGroup.requestTransitionStart -&gt; ViewRootImpl.requestTransitionStart），待下次Vsync信号到来时，才真正地开始动画。可参考ViewRootImpl.performTraversals（执行View重绘的地方）方法，关键代码如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">           <span class="comment">//调用LayoutTransition.startChangingAnimations启动Change动画。</span></span><br><span class="line">           mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">        &#125;</span><br><span class="line">    mPendingTransitions.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于Change动画的处理逻辑可以简单理解为：</p>
<font color="blue"> <strong> 当我们得知父ViewGroup的布局发生变更时，我们并不能明确具体哪一个子View的Layout布局会发生改变。因此，我们会为每一个子View添加一个View.OnLayoutChangeListener监听器，并在该监听器内完成对应Change动画的设置(<code>主要是获取改变后Layout参数值，作为动画结束时的属性值</code>)。这样对于那些Layout布局发生变化的子View来说，它的Change动画就会得到执行；而那些Layout布局没有发生变化的子View，根本就没有必要启动Change动画。</strong></font>

<p>至此，添加子View导致的APPEARING动画和CHANGE_APPEARING动画的执行流程都分析完了，删除子View的流程和此类似，此处不再赘述。</p>
<p>下面我们看下通过View.setVisibility()改变View的可见性时的流程是怎样的。通过阅读ViewGroup的代码，可知，ViewGroup.onChildVisibilityChanged方法负责View可见性的变更处理，关键代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newVisibility == VISIBLE) &#123;</span><br><span class="line">     mTransition.showChild(<span class="keyword">this</span>, child, oldVisibility);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     mTransition.hideChild(<span class="keyword">this</span>, child, newVisibility);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据View变更之后的可见性，分别调用LayoutTransition的showChild和hideChild方法，而showChild方法居然调用到了LayoutTransition.addChild方法，hideChild方法也调用了LayoutTransition.removeChild方法。下面的流程就和上面分析的添加子View的流程相同了。</p>
<p>其实，仔细想想，改变子View的可见性带来的UI上的行为和添加删除子View基本一致，唯一的一点不同就是设置为INVISIBLE属性后，子View还是占据了原来的位置，这样其他子View的Layout也不会发生改变，也就不用生成Change动画了。这在LayoutTransition.addChild方法里，会根据changesLayout参数，进行判断要不要触发Change动画，可参加上面LayoutTransition.addChild方法的介绍。</p>
<p>至此，LayoutTransition的实现机制简单梳理了一遍，可见，LayoutTransition在底层也是通过Property Animator来实现的。</p>
<h3 id="LayoutAnimationController"><a href="#LayoutAnimationController" class="headerlink" title="LayoutAnimationController"></a>LayoutAnimationController</h3><p>LayoutAnimationController用于为一个ViewGroup里的子View设置动画效果，可以在XML文件中设置，也可以通过Java Code来设置。</p>
<h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><h5 id="XML资源文件"><a href="#XML资源文件" class="headerlink" title="XML资源文件"></a>XML资源文件</h5><p>首先，在anim文件夹下定义layoutAnimation资源文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">android:delay</span>=<span class="string">"0.6"</span></span><br><span class="line">    <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span><br><span class="line">    <span class="attr">android:animation</span>=<span class="string">"@anim/anim_in"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">android:delay表示子View动画之间的时间间隔因子，最终的时间间隔为delay*duration.</span><br><span class="line">android:animationOrder表示子View的显示顺序，random表示随机显示，normal表示顺序显示，reverse表示倒序显示。</span><br><span class="line">android:animation则指向具体的Tween Animation资源文件。关于Tween Animation的XML文件如何定义，在之前的Android动画框架(1)已有介绍，此处不再赘述。</span><br></pre></td></tr></table></figure></p>
<p>然后，在需要设置动画效果的ViewGroup标签上设置如下属性即可：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:layoutAnimation="@anim/layoutAnimation_xx"，即第一步中的layoutAnimation资源文件。</span><br></pre></td></tr></table></figure></p>
<h5 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的Tween Animation</span></span><br><span class="line">ScaleAnimation sa = <span class="keyword">new</span> ScaleAnimation(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">sa.setDuration(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//根据具体Tween Animation和动画时间间隔因子创建LayoutAnimationController</span></span><br><span class="line">LayoutAnimationController lac = <span class="keyword">new</span> LayoutAnimationController(sa, <span class="number">0.6f</span>);</span><br><span class="line"><span class="comment">//设置控件显示顺序</span></span><br><span class="line">lac.setOrder(LayoutAnimationController.ORDER_REVERSE);</span><br><span class="line"><span class="comment">//设置到具体的ViewGroup</span></span><br><span class="line">viewGroup.setLayoutAnimation(lac);</span><br></pre></td></tr></table></figure>
<p>从具体使用方式，可知，我们仅仅为LayoutAnimationController设置了一种动画，因此，ViewGroup的每一个子View实际使用的是相同的动画，只不过每个子View的动画开始时间不同，LayoutAnimationController会根据每个子View的索引值，计算出不同的延迟时间，以实现多个子View的序列化显示。</p>
<p>关于LayoutAnimationController的使用，网上的资料很多，此处不再赘述，可以参考<a href="http://blog.csdn.net/imdxt1986/article/details/6952943" target="_blank" rel="external">这里</a>。</p>
<h4 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h4><p>从上面的使用方式，可知，LayoutAnimationController是借助Tween Animation来对子View实施动画效果的。因此，LayoutAnimationController的实现应该和Tween Animation类似，仔细阅读了这部分代码，发现在ViewGroup.dispatchDraw方法实现了LayoutAnimationController机制。关键代码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若为ViewGroup设置了mLayoutAnimationController,则应用布局动画</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class="number">0</span> &amp;&amp; canAnimate()) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="comment">//只有可见的子View才会有动画效果。</span></span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams params = child.getLayoutParams();</span><br><span class="line">            <span class="comment">//这里主要是为子View的布局参数params设置layoutAnimationParameters属性，该属性类是LayoutAnimationController的内部类，封装了子View的索引值和子View的个数，在计算每个子View动画的延迟时间时，会用到。</span></span><br><span class="line">            attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class="line">            <span class="comment">//这里是为每个子View绑定Tween Animation</span></span><br><span class="line">            bindLayoutAnimation(child);</span><br><span class="line">            <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                child.setDrawingCacheEnabled(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (buildCache) &#123;</span><br><span class="line">                    child.buildDrawingCache(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> LayoutAnimationController controller = mLayoutAnimationController;</span><br><span class="line">   controller.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，bindLayoutAnimation方法是关键，负责为每个子View绑定Tween Animation，这里是不是跟Tween Animation的实现机制很像，也是为View绑定补间动画。然后，补间动画的实现就是在下面的drawChild方法中实现，可以参考Android动画框架一。</p>
<p>可见，实现LayoutAnimationController机制的关键就是为每个子View设置合适的Tween Animation，然后每个Tween Animation的实现就交给View系统了。<br>下面我们看下bindLayoutAnimation方法（如何为每个子View设置补间动画）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindLayoutAnimation</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取每个子View的动画，然后设置到对应子View。</span></span><br><span class="line">  Animation a = mLayoutAnimationController.getAnimationForView(child);</span><br><span class="line">  child.setAnimation(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码很简单，主要是获取每个子View的动画，然后设置到对应子View。接着看下LayoutAnimationController.getAnimationForView方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Animation <span class="title">getAnimationForView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取每个子View动画的延迟执行时间。</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> delay = getDelayForView(view) + mAnimation.getStartOffset();</span><br><span class="line">  <span class="comment">//保存最大延迟时间，判断整个动画是否结束时有用。</span></span><br><span class="line">  mMaxDelay = Math.max(mMaxDelay, delay);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//copy一个之前设置的动画，可见所有子View拥有相同的动画，只是延迟时间不同</span></span><br><span class="line">      <span class="keyword">final</span> Animation animation = mAnimation.clone();</span><br><span class="line">       <span class="comment">//设置延迟执行时间。</span></span><br><span class="line">      animation.setStartOffset(delay);</span><br><span class="line">      <span class="keyword">return</span> animation;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码思路很清晰，首先获取每个子View动画的延迟执行时间，然后copy一份Tween Animation，为每个子View动画设置不同的延迟时间。其中，getDelayForView方法负责计算每个子View的延迟时间,其关键代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取配置</span></span><br><span class="line">ViewGroup.LayoutParams lp = view.getLayoutParams();</span><br><span class="line">AnimationParameters params = lp.layoutAnimationParameters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据时间间隔因子mDelay和子View的索引值，计算延迟时间。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> delay = mDelay * mAnimation.getDuration();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> viewDelay = (<span class="keyword">long</span>) (getTransformedIndex(params) * delay);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> totalDelay = delay * params.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mInterpolator == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mInterpolator = <span class="keyword">new</span> LinearInterpolator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> normalizedDelay = viewDelay / totalDelay;</span><br><span class="line">normalizedDelay = mInterpolator.getInterpolation(normalizedDelay);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>) (normalizedDelay * totalDelay);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，主要是根据时间间隔因子mDelay和子View的索引值，计算出每个子View的延迟时间，还可以根据插值器，来调整延迟时间。getTransformedIndex方法负责计算每个子View的索引值，因为在ORDER_REVERSE、ORDER_RANDOM和ORDER_NORMAL模式下，每个子View的索引值可能是不同的，代码比较简单，这里不再赘述。</p>
<p>这里仅是getDelayForView方法的默认实现，若我们想实现不同的显示顺序，可以重写getDelayForView方法，定制个性化效果。</p>
<p>至此，两种布局动画都已简单介绍完毕，简单总结下：</p>
<ol>
<li>LayoutTransition是在ViewGroup的布局发生变化时，对各个子View执行不同的属性动画，以实现子View的过度效果，不至于特别僵硬的切换。对于同一种类型的LayoutTransition动画，各个子View动画是同时进行的。LayoutTransition在底层是依赖于Property Animator来实现的。</li>
<li>LayoutAnimationController一般用在第一次加载ListView或者GridView的时候，希望能有个动画效果，来达到一个很好的过度效果。在后续添加或者删除子View时，都不会再有动画了。各个子View动画拥有不同的延迟时间。底层依赖于Tween Animation来实现。</li>
</ol>
<hr>
<p>其实，除了这几篇讲的几种动画之外，我们还可以通过View.postOnAnimation和View.postOnAnimationDelayed来实现自定义动画，基本包括以下几个步骤：</p>
<ol>
<li>通过postOnAnimation方法，发送Runnable，在下一帧到来时，变换属性，实现动画效果。</li>
<li>在Runnable中计算View的各类属性值，更新View的属性。</li>
<li>如果动画还需要继续执行，在Runnable中postOnAnimation到下一个时间帧，以实现循环。否则，直接结束动画。</li>
</ol>
<p>大致框架如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Runnable mAnimationRunnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span><br><span class="line">    </span>&#123; </span><br><span class="line">      <span class="comment">//计算动画属性值 </span></span><br><span class="line">      <span class="keyword">boolean</span> isAnimation = calculateAnimation();  </span><br><span class="line">      <span class="comment">//根据最新的动画属性值，修改View的对应属性</span></span><br><span class="line">      applyForViews();</span><br><span class="line">      <span class="keyword">if</span>(isAnimation)&#123; <span class="comment">//继续执行动画</span></span><br><span class="line">         mView.postOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;;  </span><br><span class="line">mView.postOnAnimation(mAnimationRunnable);<span class="comment">//开启动画</span></span><br></pre></td></tr></table></figure></p>
<p>OK，到此为止，我们简单梳理了Frame Animation、Tween Animation、Property Animator和Layout Animation的使用方式和实现机制，其中有一些地方难免有错误，还烦请大神们指点一二哈。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/Android动画框架二/" itemprop="url">
                  Android动画框架二
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T14:03:56+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/Android动画框架二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/Android动画框架二/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/27/Android动画框架二/" class="leancloud_visitors" data-flag-title="Android动画框架二">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇接Android动画框架一,上篇文章主要介绍了Frame Animation和Tween Animation的使用方式和实现机制。本篇主要介绍Property Animator.</p>
<h2 id="Property-Animator"><a href="#Property-Animator" class="headerlink" title="Property Animator"></a>Property Animator</h2><p>之前我们学习的Frame Animation和Tween Animation是Android3.0之前就存在的动画，但是他们存在着一些不足。因此，从Android3.0开始，Google为Android系统添加了更加强大的动画，即属性动画，它可以改变任何对象的属性，可谓动画界的终极武器哈！Property Animator更改的是对象的实际属性，而Tween Animation改变的则是View的绘制效果，真正的View的属性保持不变。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>Property Animator中有两个类可以实现属性的改变，分别是：ObjectAnimator和ValueAnimator，其中ValueAnimator是ObjectAnimator的父类，它是Property Animator的时间引擎，负责计算各个帧的属性值。ValueAnimator定义了属性动画的绝大部分核心功能，包括计算各帧的相关属性值，负责处理属性更新事件，按属性值的类型控制计算规则等。属性动画主要由两部分构成：</p>
<ol>
<li>计算各帧的相关属性值。</li>
<li>为指定对象设置这些计算后的值。</li>
</ol>
<p>其中，ValueAnimator只负责第一方面的内容，ObjectAnimator则会完成两部分的内容，因此我们优先选用ObjectAnimator，若由于各种限制无法使用，则选择ValueAnimator。ValueAnimator本身不作用于任何对象，也就是说直接使用它没有任何动画效果。但是，它可以对一个值做动画，然后我们可以监听其动画过程，在动画过程中修改指定对象的属性值，这样也就相当于对我们的对象做了动画，即我们自己来完成第二部分。</p>
<p>下面首先来看通过ObjectAnimator来实现属性动画，也包括XML资源文件和Java Code两种方式：</p>
<h4 id="XML资源文件（放在animator目录下）"><a href="#XML资源文件（放在animator目录下）" class="headerlink" title="XML资源文件（放在animator目录下）"></a>XML资源文件（放在animator目录下）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">   <span class="attr">android:duration</span>=<span class="string">"1000"</span> //动画持续时间</span><br><span class="line">   <span class="attr">android:propertyName</span>=<span class="string">"scaleX"</span> //要改变的属性值</span><br><span class="line">   <span class="attr">android:valueFrom</span>=<span class="string">"1.0"</span>  //动画开始时的属性值</span><br><span class="line">   <span class="attr">android:valueTo</span>=<span class="string">"2.0"</span>    //动画结束时的属性值</span><br><span class="line">   <span class="attr">android:valueType</span>=<span class="string">"floatType"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后加载资源文件，设置宿主对象，开始动画：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator anim = AnimatorInflater.loadAnimator(Context, R.animator.scalex);  </span><br><span class="line">anim.setTarget(view);  </span><br><span class="line">anim.start()</span><br></pre></td></tr></table></figure></p>
<h4 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(view,<span class="string">"scaleX"</span>,<span class="number">1.0f</span>,<span class="number">2.0f</span>);</span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure>
<p>上面两种方式实现了对View的缩放动画，但是View必须提供SetScaleX方法，才能接受属性的改变。同时，若没有提供动画开始时的属性值，那么还必须提供getScaleX方法，来提供动画起始时的属性值。虽然，两种方式都可以实现属性动画，但是我更喜欢直接Java Code的方式，直观、高效。</p>
<p>要通过<code>ObjectAnimator</code>实现属性动画有一些条件必须满足：</p>
<ol>
<li>object必须要提供setXxx方法，如果动画的时候没有传递初始值，那么还要提供getXxx方法，因为系统要去拿xxx属性的初始值（如果这条不满足，程序直接Crash）</li>
<li>object的setXxx对属性xxx所做的改变必须能够通过某种方法反映出来，比如会带来ui的改变啥的，一般通过调用invalidate来实现（如果这条不满足，动画无效果但不会Crash）</li>
</ol>
<p>以上条件缺一不可。</p>
<p>可见，要使用ObjectAnimator，有一些苛刻的条件，但是没有什么事是必然的。针对上述问题，Google告诉我们3种解决方案：</p>
<ol>
<li>直接的方式：若你有权限，给你的对象加上get和set方法。</li>
<li>方便的方式：用一个类来包装原始对象，间接为其提供get和set方法。</li>
<li>妥协的方式：使用ValueAnimator，自己监听动画过程，实现属性的改变，这也是最灵活的方式。</li>
</ol>
<p>我们来分析下这三种方案：</p>
<p>1.第一种方式很好理解哈，没有？那就直接Code上去呗，Fuck，我没有权限哈。这种方式看上去很好，但是很多情况下，我们都没有相应的权限。<br>2.第二种方式很有用，假如我们想动态改变Button的宽度，如果我们使用ObjectAnimator直接操作Button的<code>width</code>属性，你会发现根本不起作用。查阅了Button的（其实是继承的TextView的方法）setWidth方法，发现它的作用不是设置View的宽度，而是设置Button的最大宽度和最小宽度。好吧，原来，我们设置View的宽度和高度，是在资源文件里通过<code>android:layout_width</code>来完成的，但是这货在View中又没有直接的set和get方法。那就来包装一下吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ButtonWrapper</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> View mTarget;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ViewWrapper</span><span class="params">(View target)</span> </span>&#123;  </span><br><span class="line">      mTarget = target;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> mTarget.getLayoutParams().width;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;  </span><br><span class="line">      mTarget.getLayoutParams().width = width;  </span><br><span class="line">      mTarget.requestLayout();  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后通过以下方式，就可以从原来的宽度，在1000ms内，变成宽500px.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewWrapper wrapper = <span class="keyword">new</span> ViewWrapper(mButton);  </span><br><span class="line">ObjectAnimator.ofInt(wrapper, <span class="string">"width"</span>, <span class="number">500</span>).setDuration(<span class="number">1000</span>).start();</span><br></pre></td></tr></table></figure></p>
<p>3.第三种方式最灵活，我们自己来处理属性的改变，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator anim = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">500</span>);</span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener() &#123;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;  </span><br><span class="line">        Float value = (Float) animation.getAnimatedValue();<span class="comment">//获取当前属性值  </span></span><br><span class="line">        mButton.getLayoutParams().width = width;  </span><br><span class="line">       	mButton.requestLayout();   </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p>
<p>ObjectAnimator默认只能动态变换一个属性，但是我们也可以通过多种方式来实现同时变换类对象的多个属性，主要包括以下几种：</p>
<h4 id="借助PropertyValuesHolder类来实现"><a href="#借助PropertyValuesHolder类来实现" class="headerlink" title="借助PropertyValuesHolder类来实现"></a>借助PropertyValuesHolder类来实现</h4><p>PropertyValuesHolder代表一个属性和具体的属性值集合，通过PropertyValuesHolder就可以构建ObjectAnimator对象了，其实通过ofInt等方法来创建ObjectAnimator对象，最终也会把这些属性值封装成PropertyValuesHolder对象,具体实现方式如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder x = PropertyValuesHolder.ofFloat(<span class="string">"x"</span>,<span class="number">150</span>);</span><br><span class="line">PropertyValuesHolder y = PropertyValuesHolder.ofFloat(<span class="string">"y"</span>,<span class="number">150</span>);</span><br><span class="line">ObjectAnimator.ofPropertyValuesHolder(myView, x, y).setDuration(<span class="number">1000</span>).start();</span><br></pre></td></tr></table></figure></p>
<h4 id="借助ViewPropertyAnimator类来实现"><a href="#借助ViewPropertyAnimator类来实现" class="headerlink" title="借助ViewPropertyAnimator类来实现"></a>借助ViewPropertyAnimator类来实现</h4><p>根据官方文档可知，ViewPropertyAnimator类使用一个单一的Animator对象，对一个View对象的多个属性同时进行并行操作。它的行为非常像ObjectAnimator类，因为它也修改了View对象属性的实际值，但是当多个动画属性同时进行时，它会更加高效。另外，使用ViewPropertyAnimator类的代码更加简洁和易于阅读。<br>若仅仅动画一个或者两个属性，那么可以直接使用ObjectAnimator。但是若同时动画多个属性，那么ViewPropertyAnimator更加高效和可读，具体代码如下所示，其中myView.animate()获取的就是ViewPropertyAnimator类对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myView.animate().x(<span class="number">150f</span>).y(<span class="number">150f</span>).start();</span><br></pre></td></tr></table></figure></p>
<p>很简单吧，但是该方式必须在api 12及之上的版本才能使用。</p>
<h4 id="借助ValueAnimator类，自己实现多属性变换"><a href="#借助ValueAnimator类，自己实现多属性变换" class="headerlink" title="借助ValueAnimator类，自己实现多属性变换"></a>借助ValueAnimator类，自己实现多属性变换</h4><p>我们可以监听ValueAnimator的动画变换进度值，然后把进度值同时作用在多个属性之上，这种方式最灵活。假如：我们要同时改变View的X和Y值，分别从50动画到150，那么可以通过以下方式来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator valueAnimator = ValueAnimator.ofFloat(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">valueAnimator.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener() &#123;</span><br><span class="line">   <span class="comment">//持有一个FloatEvaluator对象，下面估值的时候使用,关于TypeEvaluator下面会进行介绍  </span></span><br><span class="line">   FloatEvaluator mEvaluator = <span class="keyword">new</span> FloatEvaluator();</span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animator)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">float</span> fraction = (Float)animator.getAnimatedValue();<span class="comment">//获得动画进度值</span></span><br><span class="line">      myView.setX(mEvaluator.evaluate(fraction,<span class="number">50.0f</span>,<span class="number">150.0f</span>));<span class="comment">//变换X值</span></span><br><span class="line">      myView.setY(mEvaluator.evaluate(fraction,<span class="number">50.0f</span>,<span class="number">150.0f</span>));<span class="comment">//变换Y值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;); </span><br><span class="line">valueAnimator.setDuration(<span class="number">1000</span>).start();</span><br></pre></td></tr></table></figure></p>
<h4 id="借助AnimatorSet类来实现"><a href="#借助AnimatorSet类来实现" class="headerlink" title="借助AnimatorSet类来实现"></a>借助AnimatorSet类来实现</h4><p>AnimatorSet类是一个Animator集合，用于实现多个动画的协同作用，包括多个动画的并行执行、串行执行、延迟执行或者结合多者实现任意的组合，是很灵活的动画操作方案。还是以上面的例子为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animX = ObjectAnimator.ofFloat(myView, <span class="string">"x"</span>, <span class="number">50f</span>,<span class="number">150f</span>);</span><br><span class="line">ObjectAnimator animY = ObjectAnimator.ofFloat(myView, <span class="string">"y"</span>, <span class="number">50f</span>,<span class="number">150f</span>);</span><br><span class="line">AnimatorSet animXY = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">animXY.setDuration(<span class="number">1000</span>); </span><br><span class="line">animXY.playTogether(animX,animY);</span><br><span class="line">animSetXY.start();</span><br></pre></td></tr></table></figure></p>
<p>AnimatorSet还可以实现更多的动画组合，例如：通过playSequentially可以实现动画的串行执行；animSet.play(anim1).before(anim2).before(anim3)可以实现先动画anim1，然后同时动画anim2和anim3；animSet.play(anim1).after(anim2)则可以实现先动画anim2，然后动画anim1；关于AnimatorSet的使用可以参考官方文档，此处不再赘述。</p>
<p>关于属性动画，还有一个很重要的类<code>keyFrame</code>，它表示一个动画进度值(<code>经过插值器处理过的进度值</code>)/属性值，通过它可以定义一个特定时间点的关键帧，而且在两个keyFrame之间还可以定义不同的Interpolator，就好像多个动画的拼接，第一个动画的结束点是第二个动画的开始点,如下所示，为定制myView的Y坐标的动态变换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数表示动画进度百分比(经过插值器处理过的进度值)，基于0和1之间，第二个参数表示对应的属性值。</span></span><br><span class="line">Keyframe kf0 = Keyframe.ofFloat(<span class="number">0</span>, <span class="number">50f</span>);  </span><br><span class="line">Keyframe kf1 = Keyframe.ofFloat(<span class="number">0.25f</span>, <span class="number">100f</span>);  </span><br><span class="line">Keyframe kf2 = Keyframe.ofFloat(<span class="number">0.5f</span>, <span class="number">300f</span>);  </span><br><span class="line">Keyframe kf3 = Keyframe.ofFloat(<span class="number">0.75f</span>, <span class="number">100f</span>);  </span><br><span class="line">Keyframe kf4 = Keyframe.ofFloat(<span class="number">1f</span>, <span class="number">50f</span>);  </span><br><span class="line">PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(<span class="string">"y"</span>, kf0, kf1, kf2, kf3, kf4);  </span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(myView, pvhRotation);  </span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p>
<p>上面的动画表示动画开始时X=50，进行到1/4时，X=100，进行到一半时，X=300,进行到3/4时，X=100,最后动画结束时，X又变回了50.</p>
<p>下面来看下估值器Evaluator，它主要负责根据属性的开始值、结束值与动画进度值，计算出当前的属性值。基类为TypeEvaluator，仅仅包括一个方法evaluate(float fraction, T startValue, T endValue)，其中fraction表示动画进度值，基于0和1之间（经过插值器处理过的），startValue表示属性起始值，endValue表示属性结束值。系统提供了4个实现类，分别对应不同的属性类型</p>
<ul>
<li>IntEvaluator：属性值类型为int；</li>
<li>FloatEvaluator：属性值类型为float；</li>
<li>ArgbEvaluator：属性值类型为十六进制颜色值；</li>
<li>RectEvaluator：属性值为Rect表示的矩形区域；</li>
</ul>
<p>若这个4种类型不符合我们的要求，那么我们可以继承TypeEvaluator，实现evaluate方法，来定制自己的估值器，很简单哈。<br>关于属性动画的使用方式，网上有很多案例，此处不再赘述，下面我们看下属性动画是如何实现的。</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>对于属性动画，不管通过哪种方式来实现，总要调用Animator.start()方法开始动画，因此我们从ObjectAnimator.start()方法入手，分析其实现机制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AnimationHandler负责处理所有的不同状态的Animator，是属性动画的核心。</span></span><br><span class="line">AnimationHandler handler = sAnimationHandler.get();</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//处理当前激活的动画，若他们和当前动画实现相同的效果，则取消这些动画。</span></span><br><span class="line">    <span class="keyword">int</span> numAnims = handler.mAnimations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numAnims - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.mAnimations.get(i) <span class="keyword">instanceof</span> ObjectAnimator) &#123;</span><br><span class="line">            ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i);</span><br><span class="line">            <span class="keyword">if</span> (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</span><br><span class="line">                anim.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理等待的动画，若他们和当前动画实现相同的效果，则取消这些动画。</span></span><br><span class="line">    numAnims = handler.mPendingAnimations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numAnims - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.mPendingAnimations.get(i) <span class="keyword">instanceof</span> ObjectAnimator) &#123;</span><br><span class="line">            ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i);</span><br><span class="line">            <span class="keyword">if</span> (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</span><br><span class="line">                anim.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理延迟的动画，若他们和当前动画实现相同的效果，则取消这些动画。</span></span><br><span class="line">    numAnims = handler.mDelayedAnims.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numAnims - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.mDelayedAnims.get(i) <span class="keyword">instanceof</span> ObjectAnimator) &#123;</span><br><span class="line">            ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i);</span><br><span class="line">            <span class="keyword">if</span> (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</span><br><span class="line">                anim.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.start();<span class="comment">//调用父类的start方法</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码虽然很长，但做的事情很简单，如果当前激活的动画、等待的动画（Pending）和延迟的动画（Delay）中有和当前动画相同的动画，那么就把相同的动画给取消掉。然后调用父类ValueAnimator的start方法，其精简后的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可见，启动动画的线程必须是Looper线程，</span></span><br><span class="line"><span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AnimationHandler animationHandler = getOrCreateAnimationHandler();</span><br><span class="line">animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);<span class="comment">//把当前动画添加到即将执行的动画集合中</span></span><br><span class="line"><span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) &#123; <span class="comment">//若没有延迟，则立即开始动画</span></span><br><span class="line">    setCurrentPlayTime(<span class="number">0</span>);<span class="comment">//这里会计算第一帧动画的属性值，其实这里的逻辑和 animationHandler中的逻辑类似，下面直接分析animationHandler.start方法。</span></span><br><span class="line">    mPlayingState = STOPPED;</span><br><span class="line">    mRunning = <span class="keyword">true</span>;</span><br><span class="line">    notifyStartListeners();<span class="comment">//通知动画开始的回调</span></span><br><span class="line">&#125;</span><br><span class="line">animationHandler.start();</span><br></pre></td></tr></table></figure></p>
<p>由代码和官方文档可知，被启动的Animator会运行在当前线程中（调用start方法的线程），并且该线程必须是Looper线程。如果该属性动画是对View的属性做动画，那么必须在主线程中调用start方法。（因为要动态修改View的属性，自然要在UI线程），上面的代码最终会调用到AnimationHandler.start方法，这个AnimationHandler并不是Handler，而是一个Runnable。</p>
<p>AnimationHandler.start方法又会调用AnimationHandler.scheduleAnimation方法。而该方法会把AnimationHandler添加到mChoreographer的动画队列中，待Vsync信号到来时，会触发AnimationHandler.run方法的执行。在上一篇文章中我们提到过Choreographer，他负责控制用户的input事件、View的绘制和动画等行为，并且会驱动Frame Animation、Tween Animation的执行，这里又和Property Animator相关来起来，可见这货真是核心啊，别急，我们先把接着把属性动画的流程分析完，最后再来学习下Choreographer，这里只要知道当Vsync信号到来时，会触发AnimationHandler.run方法就可以了。</p>
<p>AnimationHandler.run方法会调用doAnimationFrame方法，我们来看下该方法（精简后）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面省略的代码主要是把等待的动画（Pending）、达到执行时间的延迟动画（Delay）添加到激活的动画队列中（mAnimations）,然后在下面统一处理。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numAnims = mAnimations.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">    <span class="comment">//这里又拷贝一份，主要是为了避免并发修改导致的问题</span></span><br><span class="line">    mTmpAnimations.add(mAnimations.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里动画的最终执行会交给doAnimationFrame方法来处理，frameTime表示动画执行的时间，他的返回值表示动画是否结束了，true表示动画已经结束。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">    ValueAnimator anim = mTmpAnimations.get(i);</span><br><span class="line">    <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime))                     <span class="comment">//若动画已经结束，直接添加到结束动画列表中</span></span><br><span class="line">        mEndingAnims.add(anim);</span><br><span class="line">&#125;</span><br><span class="line">mTmpAnimations.clear();</span><br><span class="line"><span class="keyword">if</span> (mEndingAnims.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mEndingAnims.size(); ++i) &#123;</span><br><span class="line">        mEndingAnims.get(i).endAnimation(<span class="keyword">this</span>);<span class="comment">//触发动画结束的回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEndingAnims.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If there are still active or delayed animations, schedule a future call to onAnimate to process the next frame of the animations.</span></span><br><span class="line"><span class="comment">//若还有激活的或者延迟的动画，那么继续调用scheduleAnimation方法，执行下一帧动画。</span></span><br><span class="line"><span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</span><br><span class="line">    scheduleAnimation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有两个关键点：</p>
<ol>
<li>最终是通过doAnimationFrame方法来完成属性动画；</li>
<li>若还有动画需要执行，会再调用scheduleAnimation方法，直到所有的动画都结束了。</li>
</ol>
<p>下面我们来继续看下，最终的属性值改变到底发生在哪里？<br>doAnimationFrame方法会调用animationFrame方法，该方法的关键代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据动画的执行时间，计算出当前的动画时间进度值。</span></span><br><span class="line"><span class="keyword">float</span> fraction = mDuration &gt; <span class="number">0</span> ? (<span class="keyword">float</span>)(currentTime - mStartTime) / mDuration : <span class="number">1f</span>;</span><br><span class="line"><span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123; <span class="comment">//若动画结束了，则检查下是否达到了repeat次数</span></span><br><span class="line">      <span class="keyword">if</span> (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</span><br><span class="line">          <span class="comment">// Time to repeat，若还需要继续repeat，那么先通知onAnimationRepeat回调</span></span><br><span class="line">          <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> numListeners = mListeners.size();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                   mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123; <span class="comment">//检查下是正向还是反向重复</span></span><br><span class="line">             mPlayingBackwards = !mPlayingBackwards;</span><br><span class="line">          &#125;</span><br><span class="line">          mCurrentIteration += (<span class="keyword">int</span>)fraction;</span><br><span class="line">          fraction = fraction % <span class="number">1f</span>;</span><br><span class="line">          mStartTime += mDuration;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          done = <span class="keyword">true</span>;</span><br><span class="line">          fraction = Math.min(fraction, <span class="number">1.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPlayingBackwards) &#123; <span class="comment">//若是反向重复，则处理下时间进度值</span></span><br><span class="line">        fraction = <span class="number">1f</span> - fraction;</span><br><span class="line">    &#125;</span><br><span class="line">    animateValue(fraction);<span class="comment">//负责计算动画帧的属性值</span></span><br></pre></td></tr></table></figure></p>
<p>接下来看下animateValue方法，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据设置的插值器，把时间进度值转换为动画属性进度值，关于插值器可以参考上一篇文章。</span></span><br><span class="line">fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">mCurrentFraction = fraction;</span><br><span class="line"><span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line"><span class="comment">//计算每个属性的属性值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">    mValues[i].calculateValue(fraction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调通知当前的动画属性值，即是我们我们上面在使用ValueAnimator时，监听的动画帧属性值。</span></span><br><span class="line"><span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">        <span class="comment">//其实，到这里ValueAnimator的任务已经完成了，即通知了当前的动画属性值</span></span><br><span class="line">        mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中calculateValue方法就是计算每帧动画所对应的属性的值,该方法最终会调用到对应PropertyValuesHolder（表示一个具体的属性，前面有介绍）中mKeyframes（表示一个属性的多个属性值集合，其实就是集合了多个Keyframe，关于Keyframe前面已有介绍）属性的getValue方法。Keyframes是一个接口，根据不同的属性值类型，有不同的实现，下面我们看下IntKeyframeSet类的getValue方法实现，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNumKeyframes == <span class="number">2</span>) &#123; <span class="comment">//处理只有两个关键帧的动画</span></span><br><span class="line">        <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">            firstTime = <span class="keyword">false</span>;</span><br><span class="line">            firstValue = ((IntKeyframe) mKeyframes.get(<span class="number">0</span>)).getIntValue();</span><br><span class="line">            lastValue = ((IntKeyframe) mKeyframes.get(<span class="number">1</span>)).getIntValue();</span><br><span class="line">            deltaValue = lastValue - firstValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInterpolator != <span class="keyword">null</span>) &#123; <span class="comment">//前面已经通过插值器处理过了，这里还可以进一步处理</span></span><br><span class="line">            fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据估值器来获得最终的属性值</span></span><br><span class="line">        <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> firstValue + (<span class="keyword">int</span>)(fraction * deltaValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中间省略的是处理动画进度小于等于0或者大于等于0的情况，这里不是很理解为什么有大于1或者小于0的情况？还需要仔细考虑下</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理多个关键帧的情况，这里会根据每个Keyframe的插值器，对动画进度值再次进行调整。</span></span><br><span class="line">    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mNumKeyframes; ++i) &#123;</span><br><span class="line">        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);</span><br><span class="line">        <span class="keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;</span><br><span class="line">            <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">            <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据每个Keyframe的插值器，再次处理关键帧之间的动画进度值变换</span></span><br><span class="line">            <span class="keyword">float</span> intervalFraction = (fraction - prevKeyframe.getFraction()) /</span><br><span class="line">                (nextKeyframe.getFraction() - prevKeyframe.getFraction());</span><br><span class="line">            <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">            <span class="comment">//根据估值器来获得最终的属性值</span></span><br><span class="line">            <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                    prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                            intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        prevKeyframe = nextKeyframe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// shouldn't get here</span></span><br><span class="line">    <span class="keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="number">1</span>).getValue()).intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码虽然很长，但是很简单，基本上就是根据每个Keyframe的插值器，再次处理关键帧之间的动画进度值变换，以获得最终的动画属性值。</p>
<p>到这里为止，属性动画的分析基本结束了，但是还有一个点没有明确：ObjectAnimator在哪里对target设置的属性值。</p>
<p>仔细回顾了ValueAnimator的整个流程，发现ObjectAnimator重写了ValueAnimator的animateValue方法，也就是计算动画属性值的地方。ObjectAnimator.animateValue方法首先会调用父类的方法完成动画属性值的计算，然后会调用每个属性PropertyValuesHolder.setAnimatedValue方法，完成对对象属性的赋值。setAnimatedValue的代码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123; <span class="comment">//通过mProperty来赋值</span></span><br><span class="line">        mProperty.set(target, getAnimatedValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前属性值</span></span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = getAnimatedValue();</span><br><span class="line">            <span class="comment">//反射set方法对target对象赋值</span></span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>OK，属性动画的整个流程，我们已经完整的走下来了。<br>对于Property Animator，我们简单总结下几个关键点：</p>
<ol>
<li>Property Animator更改的是对象的实际属性，而Tween Animation改变的则是View的绘制效果，真正的View的属性保持不变。</li>
<li>Property Animator中的插值器（Interpolator）和估值器（TypeEvaluator）很重要，它是实现多种变换速率的关键，我们应该学习定制自己插值器和估值器。</li>
<li>Property Animator计算属性值可以简单理解成3步：<pre><code>1. 首先，根据动画已进行的时间和动画持续（duration），计算出一个时间因子（0~1）。
2. 然后，根据TimeInterpolator计算出动画进度因子（0~1）。
3. 最后，根据TypeEvaluator结合动画进度因子计算出属性值。 
</code></pre></li>
<li>虽然Property Animator在Android3.0之上才可以使用，但是我们可以借助NineOldAndroids开源项目来覆盖各个版本。</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/27/Kotlin基本语法2/" itemprop="url">
                  Kotlin基本语法2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T09:47:36+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/27/Kotlin基本语法2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/Kotlin基本语法2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/27/Kotlin基本语法2/" class="leancloud_visitors" data-flag-title="Kotlin基本语法2">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文承接上文<a href="http://ltlovezh.com/2016/04/17/Kotlin%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%951/" target="_blank" rel="external">Kotlin基本语法1</a>，继续介绍kotlin基础语法。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>在kotlin中，类的定义包含类名、类头和类体。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 修饰符[<span class="title">public</span>,<span class="type">internal</span>,<span class="type">protected</span>,<span class="type">private] constructor（参数：参数类型）&#123;</span></span></span><br><span class="line">  init&#123;</span><br><span class="line">    initializer blocks</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//二级构造函数，调用了主构造函数</span></span><br><span class="line">  constructor(参数：参数类型) : this(参数) &#123;</span><br><span class="line">        parent.children.add(this)</span><br><span class="line">  &#125;</span><br><span class="line">类体</span><br><span class="line">&#125;</span><br><span class="line">其中，类头和类体都是可选的。</span><br></pre></td></tr></table></figure></p>
<p>kotlin中的Class有两种构造函数：主构造函数和二级构造函数。上述<code>constructor（参数：参数类型）</code>就指定了主构造函数，它是类头的一部分。</p>
<p>主构造函数不能包含任何代码。任何初始化操作只能在<code>initializer blocks</code>中进行（可以直接引用主构造函数中的参数值）。</p>
<p>二级构造函数通过<code>constructor</code>关键字进行定义，所有的二级构造函数必须直接或者间接的调用主构造函数（通过this关键字）。</p>
<p>我们在java代码中，经常在类中定义多个属性变量，然后在构造函数中分别初始化它们。对于这种行为，kotlin提供了更加简单的方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="variable"><span class="keyword">val</span> name</span>: String = 默认参数值, <span class="variable"><span class="keyword">var</span> age</span>: <span class="keyword">Int</span> = 默认参数值) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述User类定义了两个成员变量，并在主构造函数中完成了初始化。</p>
<h2 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h2><p>在kotlin中，一个Class可以包含以下几类成员：</p>
<ol>
<li><p>Constructors and initializer blocks<br>构造函数和初始化代码块，上面已经介绍过了。</p>
</li>
<li><p>Properties<br>成员属性，下面会着重介绍。</p>
</li>
<li><p>Functions<br>成员函数，和类外部的顶级函数没啥区别，只是范围限制在Class内部了。</p>
</li>
<li><p>Nested and Inner Classes<br>在Kotlin中，内部类默认是static的，即不会持有对外部类的引用。但是被<code>inner</code>修饰的内部类是非static的，即会持有对外部类的引用。</p>
</li>
<li><p><strong>Object Declarations</strong><br>对象表达式和对象声明，下面会着重介绍。</p>
</li>
</ol>
<h3 id="Properties-（属性）"><a href="#Properties-（属性）" class="headerlink" title="Properties （属性）"></a>Properties （属性）</h3><p>类属性就相当于java中的实例成员属性，它的完整定义如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> &lt;propertyName&gt;</span>: <span class="type">&lt;PropertyType&gt;</span> [= <span class="type">&lt;property_initializer&gt;</span>]</span><br><span class="line">  [<span class="type">&lt;getter&gt;</span>]</span><br><span class="line">  [<span class="type">&lt;setter&gt;</span>]</span><br></pre></td></tr></table></figure></p>
<p>上述的<code>&lt;getter&gt;</code>和<code>&lt;setter&gt;</code>分别在读取和设置属性时被调用（编译器会默认生成）。<code>val</code>属性只有<code>&lt;getter&gt;</code>函数。<br>当然，我们可以定制属性的set和get函数，就像定义普通的函数一样。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leontli</span></span>() &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> isEmpty</span>: <span class="keyword">Boolean</span> = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> field</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，filed称为<code>backing field</code>，由编译器编译生成，仅仅可在get()和set(value)方法中被访问（若只是重写了get和set方法，而没有主动访问field字段，那么编译器也不会主动生成该字段）。</p>
<h4 id="属性的延迟初始化"><a href="#属性的延迟初始化" class="headerlink" title="属性的延迟初始化"></a>属性的延迟初始化</h4><p>在kotlin中，一般情况下，类中的成员属性，必须直接初始化或者在构造函数中初始化。但是有时这是非常不方便的。比如：我们在Activity中经常需要获取各个View的引用，然后进行各种操作。在Java中一般是先定义View变量，然后在onCreate方法中对他们初始化，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">Bubtton mButton;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.OnCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.main);</span><br><span class="line">    mButton = (Button) findViewById(R.id.ok);</span><br><span class="line">    aTextView.setText(<span class="string">"Click Me"</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是在kotlin中，这样是行不通的，因为非空属性必须被初始化一个非空值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> mButton</span> : Button <span class="comment">//error : Property must be initialized or be abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果使用可Null属性，那么后续的操作也会很繁琐，同时也失去了kotlin提供的不可Null属性的便利，可能会导致NPE的频现(又回到了java的老路)。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> mButton</span> : Button? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle?</span>)</span> &#123;</span></span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.main)</span><br><span class="line">    mButton = findViewById(R.id.ok) <span class="keyword">as</span> Button</span><br><span class="line">    <span class="comment">//因为mButton可Null，所以只能通过下面的方式来赋值</span></span><br><span class="line">    mButton!!.text = <span class="string">"Click Me"</span></span><br><span class="line">    mButton?.text = <span class="string">"Click Me"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>明明知道mButton不会为Null，但是每次调用都要添加<code>!!</code> or <code>?</code>操作符，岂不是很不爽！</p>
<p>针对这种情况，kotlin也给出了可选的解决方案<code>Late-Initialized Properties</code>和<code>Delegated Properties</code>。每种方案各有其使用场景，下面一一介绍。</p>
<h5 id="Late-Initialized-Properties（延迟初始化属性）"><a href="#Late-Initialized-Properties（延迟初始化属性）" class="headerlink" title="Late-Initialized Properties（延迟初始化属性）"></a>Late-Initialized Properties（延迟初始化属性）</h5><p>通过<code>lateinit</code>关键字可以定义延迟初始化属性。例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">Activity</span></span>() &#123;</span><br><span class="line">lateinit <span class="variable"><span class="keyword">var</span> mButton</span> : Button</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle?</span>)</span> &#123;</span></span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.main)</span><br><span class="line">    mButton = findViewById(R.id.ok) <span class="keyword">as</span> Button</span><br><span class="line">    <span class="comment">//可直接调用</span></span><br><span class="line">    mButton.text = <span class="string">"Click Me"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以满足我们的需求了（和java的写法很类似）。但是使用这种属性存在一些条件：</p>
<ol>
<li>只适用于可变属性，即<code>var</code>修饰的属性</li>
<li>只适用于Class body内的属性，不能是在主构造函数中声明的属性。</li>
<li>延迟初始化属性不能包含自定义的set和get方法</li>
<li>属性不可为Null，且属性类型不能是原始类型。</li>
</ol>
<p>毕竟存在这些限制，也就意味着在特殊情况下，无法使用延迟初始化属性。（强迫症…）</p>
<h5 id="Delegated-Properties-（委托属性-or-代理属性）"><a href="#Delegated-Properties-（委托属性-or-代理属性）" class="headerlink" title="Delegated Properties （委托属性 or 代理属性）"></a>Delegated Properties （委托属性 or 代理属性）</h5><p><code>Delegated Properties</code>为属性的初始化提供了另外一种方案，即把属性委托给一个表达式。其语法如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;property name&gt;</span>: <span class="type">&lt;Type&gt;</span> by <span class="type">&lt;expression&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>by后面的表达式称为属性代理（delegate）。针对这个delegate，存在一些限制规则：</p>
<p>1.若属性是不可变的（val修饰），那么必须提供如下形式的<code>getValue</code>函数:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(receiver: <span class="type">Any?, metadata: KProperty&lt;*&gt;</span>)</span>: 被代理属性的类型 &#123;</span></span><br><span class="line">    <span class="comment">//返回被代理属性的值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，关键字<code>operator</code>是必不可少的。参数<code>receiver</code>表示持有被代理属性的类对象，其参数类型必须是被代理属性持有者的类型或者其父类型。<code>metadata</code>表示被代理属性的元数据，其参数类型必须是KProperty&lt;*&gt;或者其父类型。</p>
<p>2.若属性是可变的（var修饰），那么还必须提供<code>setValue</code>函数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(receiver: <span class="type">Any?, metadata: KProperty&lt;*&gt;, value: 被代理属性的类型</span>)</span> &#123;</span></span><br><span class="line">    <span class="comment">//设置被代理属性的值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，receiver和metadata的含义和getValue方法类似，value则表示对被代理属性设置的新值。</p>
<p>这两个函数既可以是类成员函数，也可以是扩展函数。其中，对被代理属性的访问会被委托给delegate的<code>getValue</code>函数，对被代理属性的赋值会被委托给delegate的<code>setValue</code>函数。下面来看一个例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span>&lt;<span class="type">T</span>&gt;</span>(arg: T) &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> mSave</span>: T = arg <span class="comment">//存储被代理属性的值</span></span><br><span class="line"></span><br><span class="line">    operator <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(receiver: <span class="type">Any?, metadata: KProperty&lt;*&gt;</span>)</span>: T &#123;</span></span><br><span class="line">        println(<span class="string">"$receiver, thank you for delegating '$&#123;metadata.name&#125;' to me!"</span>)</span><br><span class="line">        <span class="keyword">return</span> mSave</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(receiver: <span class="type">Any?, metadata: KProperty&lt;*&gt;, value: T</span>)</span> &#123;</span></span><br><span class="line">        println(<span class="string">"$value has been assigned to '$&#123;metadata.name&#125; in $receiver.'"</span>)</span><br><span class="line">        mSave = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理属性的持有者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把属性p委托给Delegate类对象</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> p</span>: String by Delegate<span class="type">&lt;String&gt;</span>(<span class="string">"init"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用:</span><br><span class="line"><span class="variable"><span class="keyword">var</span> example</span> = Example();</span><br><span class="line">println(example.p)</span><br><span class="line">example.p = <span class="string">"Hello"</span></span><br><span class="line">println(example.p)</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">Example@<span class="number">74</span>f2794a, thank you <span class="keyword">for</span> delegating 'p' to me!</span><br><span class="line">init</span><br><span class="line">Hello has been assigned to 'p <span class="keyword">in</span> Example@<span class="number">74</span>f2794a.'</span><br><span class="line">Example@<span class="number">74</span>f2794a, thank you <span class="keyword">for</span> delegating 'p' to me!</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></p>
<p>从上述代码中可以看出，访问属性p时，调用了getValue方法，接收者就是Example对象，而通过元数据metadata，则可以访问被代理属性的名称等属性。而对属性p赋值时，调用了setValue方法，value则表示将要被赋值的新值。</p>
<p>上面代码中，我们用<code>mSave</code>属性存储了被代理对象的值，这是因为我们不能在getValue和setValue函数中访问被代理属性p，道理很简单，因为访问被代理属性又会触发getValue和setValue函数，导致死循环。</p>
<p>当然，上面仅仅是一个简单的例子，通过属性代理（delegate），我们可以实现任何对属性的取值和赋值操作。</p>
<p>针对委托属性，kotlin类库提供了一些现成的属性代理（delegate）。这里简单介绍下其中两种。</p>
<h6 id="Lazy"><a href="#Lazy" class="headerlink" title="Lazy"></a>Lazy</h6><p><code>lazy</code>其实是一个接收函数字面量，且返回<code>Lazy</code>对象的高阶函数。<code>Lazy</code>对象是一个delegate，实现了对被代理属性的懒加载（<code>Lazy</code>对象的getValue函数就是通过扩展函数形式来提供的）。只有属性在第一次被访问时，才会执行函数字面量对属性进行赋值。且后续属性值不可变更，即懒加载属性必须是不可变的（val修饰）。看下例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> lazyValue</span>: String by lazy &#123;</span><br><span class="line">    println(<span class="string">"computed!"</span>)</span><br><span class="line">    <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用:</span><br><span class="line">println(lazyValue)</span><br><span class="line">println(lazyValue)</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">computed!</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></p>
<h6 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h6><p><code>Delegates</code>是一个Standard property delegates。它提供了<code>observable</code>和<code>vetoable</code>函数，分别用来生成不同的属性代理。它们的函数签名如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收一个初始值和一个函数（包含属性、旧值和新值共3个参数），返回一个ObservableProperty属性代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">observable</span><span class="params">(initialValue: <span class="type">T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T</span>)</span> -&gt; <span class="keyword">Unit</span>) : ReadWriteProperty<span class="type">&lt;Any?, T&gt;</span> = <span class="keyword">object</span> : ObservableProperty<span class="type">&lt;T&gt;</span><span class="params">(initialValue)</span> &#123;</span></span><br><span class="line">        <span class="comment">//重写了afterChange函数，在被代理属性被修改后，才会被调用。</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty&lt;*&gt;, oldValue: T, newValue: T</span>)</span> = <span class="title">onChange</span><span class="params">(property, oldValue, newValue)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//接收一个初始值和一个函数（包含属性、旧值和新值共3个参数），返回一个ObservableProperty属性代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">vetoable</span><span class="params">(initialValue: <span class="type">T, crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T</span>)</span> -&gt; <span class="keyword">Boolean</span>) : ReadWriteProperty<span class="type">&lt;Any?, T&gt;</span> = <span class="keyword">object</span> : ObservableProperty<span class="type">&lt;T&gt;</span><span class="params">(initialValue)</span> &#123;</span></span><br><span class="line">        <span class="comment">//重写了beforeChange函数，在被代理属性被修改前，会被调用，若onChange返回了false，则赋值会被终止掉。</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeChange</span><span class="params">(property: <span class="type">KProperty&lt;*&gt;, oldValue: T, newValue: T</span>)</span>: <span class="keyword">Boolean</span> = <span class="title">onChange</span><span class="params">(property, oldValue, newValue)</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>前者<code>observable</code>接收的参数函数会在赋值之后被调用，后者<code>vetoable</code>接收的参数函数会在赋值之前被调用，并且有权中断赋值。我们可以想一下，这种控制逻辑应该是在ObservableProperty属性代理的setValue方法中实现的。果不其然：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any?, property: KProperty&lt;*&gt;, value: T</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> oldValue</span> = this.value</span><br><span class="line">    <span class="comment">//真正赋值之前的调用，若beforeChange返回了false，则中断赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!beforeChange(property, oldValue, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.value = value <span class="comment">//真正赋值</span></span><br><span class="line">    <span class="comment">//赋值之后的调用，若beforeChange返回了false，则不会走到这里</span></span><br><span class="line">    afterChange(property, oldValue, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是总感觉有些遗憾，为什么没有函数既可以在赋值前被调用，又可以在赋值后被调用那？其实这也是可以理解的，若是<code>beforeChange</code>函数返回了false，那么<code>afterChange</code>便不会被调用；若是<code>beforeChange</code>函数返回了true，那么<code>afterChange</code>的参数和前者完全是一样的，就没啥意义了。</p>
<p>但是，出于练习目的，我们完全可以实现这种函数，基本思路就是为<code>Delegates</code>类提供扩展函数，返回同时实现了<code>beforeChange</code>和<code>afterChange</code>的ObservableProperty属性代理对象。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initialValue是初始值，onBefore在赋值前被调用，onAfter在赋值后被调用</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span>  <span class="type">&lt;T&gt;</span> Delegates.<span class="title">all</span><span class="params">(initialValue: <span class="type">T,</span><br><span class="line">    crossinline onBefore: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T</span>)</span> -&gt; <span class="keyword">Boolean</span>,</span></span><br><span class="line">    crossinline onAfter: (property: KProperty<span class="type">&lt;*&gt;</span>, oldValue: T, newValue: T) -&gt; <span class="keyword">Unit</span>):</span><br><span class="line">        ReadWriteProperty<span class="type">&lt;Any?, T&gt;</span> = <span class="keyword">object</span> : ObservableProperty<span class="type">&lt;T&gt;</span>(initialValue) &#123;</span><br><span class="line">    <span class="comment">//重写了两个函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeChange</span><span class="params">(property: <span class="type">KProperty&lt;*&gt;, oldValue: T, newValue: T</span>)</span>: <span class="keyword">Boolean</span> = <span class="title">onBefore</span><span class="params">(property, oldValue, newValue)</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty&lt;*&gt;, oldValue: T, newValue: T</span>)</span> = <span class="title">onAfter</span><span class="params">(property, oldValue, newValue)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们通过扩展函数<code>all</code>，综合了<code>observable</code>和<code>vetoable</code>的功能。传入的参数<code>onBefore</code>会在赋值前被调用，onAfter会在赋值后被调用（赋值不被中断的前提下）。下面看下具体使用:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="comment">//isPass也是被代理属性，在使用前必须先赋值</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> isPass</span>: <span class="keyword">Boolean</span> by Delegates.notNull<span class="type">&lt;Boolean&gt;</span>()</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> name</span>: String by Delegates.all(<span class="string">"&lt;no name&gt;"</span>, &#123; prop, old, new -&gt;</span><br><span class="line">        println(<span class="string">"before $old -&gt; $new"</span>)</span><br><span class="line">        isPass <span class="comment">//闭包哈</span></span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        prop, old, new -&gt;</span><br><span class="line">        println(<span class="string">"after $old -&gt; $new"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用:</span><br><span class="line"><span class="variable"><span class="keyword">var</span> example</span> = Example();</span><br><span class="line">example.isPass = <span class="literal">true</span></span><br><span class="line">println(example.name)</span><br><span class="line">example.name = <span class="string">"leon"</span></span><br><span class="line">println(example.name)</span><br><span class="line"></span><br><span class="line">example.isPass = <span class="literal">false</span></span><br><span class="line">example.name = <span class="string">"android"</span></span><br><span class="line">println(example.name)</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="type">&lt;no name&gt;</span></span><br><span class="line">before <span class="type">&lt;no name&gt;</span> -&gt; leon</span><br><span class="line">after <span class="type">&lt;no name&gt;</span> -&gt; leon</span><br><span class="line">leon</span><br><span class="line">before leon -&gt; android </span><br><span class="line"><span class="comment">//这里赋值被阻断后，after没有执行哈</span></span><br><span class="line">leon</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-Expressions-and-Declarations-对象表达式和对象声明"><a href="#Object-Expressions-and-Declarations-对象表达式和对象声明" class="headerlink" title="Object Expressions and Declarations (对象表达式和对象声明)"></a>Object Expressions and Declarations (对象表达式和对象声明)</h3><p>对象表达式和对象声明都是用来创建对象的。其中，前者用来创建匿名类对象，可以直接赋值给一个变量；后者用来创建单例对象，不可直接赋值给一个变量。</p>
<p>除此之外，两者还有一个重要的差异：Object Expressions在定义的地方被立即执行；而Object Declarations则会延迟到第一次被访问时才会执行。</p>
<h4 id="Object-Expressions-（对象表达式）"><a href="#Object-Expressions-（对象表达式）" class="headerlink" title="Object Expressions （对象表达式）"></a>Object Expressions （对象表达式）</h4><p>对象表达式的格式如下所示。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> 单例对象名 ： 父类 , 接口<span class="number">1</span> , 接口<span class="number">2</span> , ...&#123;</span><br><span class="line">    <span class="comment">//实现自定义方法和接口方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后续就可以通过<code>单例对象名</code>来访问对象方法了。但是不可以在函数内进行对象声明。</p>
<h4 id="Companion-Objects"><a href="#Companion-Objects" class="headerlink" title="Companion Objects"></a>Companion Objects</h4><p>在Kotlin中，没有静态方法，而是推荐使用顶级函数来代替。但是我们可以通过<code>Companion Objects</code>来实现类似静态方法的方法。</p>
<p>具体方式是在类内部的Object Declarations前面加上<code>Companion</code>关键字。这样我们就可以像使用类静态方法一样，直接通过类名调用<code>Companion Objects</code>内的方法了。看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OurClass</span> </span>&#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span>: OurClass &#123; </span></span><br><span class="line">        <span class="comment">//error,无法访问外部类的属性。从这里可以看出Factory更像是静态内部类，不过有待确认？</span></span><br><span class="line">        println(<span class="string">"a = $a"</span>) </span><br><span class="line">        <span class="keyword">return</span> OurClass()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">println(OurClass.create())</span><br><span class="line">println(OurClass.Factory.create())</span><br><span class="line">println(OurClass.Factory)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">OurClass@<span class="number">3e99</span>f610</span><br><span class="line">OurClass@<span class="number">6</span>de9b48b</span><br><span class="line">OurClass$Factory@a4c4a0d</span><br></pre></td></tr></table></figure>
<p>从上面的输出可以看出，create方法不是真正的static方法，而是内部类Factory的实例方法。因此，Factory也可以像普通的Object Declarations一样，实现接口。</p>
<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>在Kotlin中，所有的Kotlin类都有一个共同的父类<code>Any</code>（不是java.lang.Object）。<br>默认情况下，一个Kotlin类不可以被继承，成员函数也不可以被重写（这点和java不同，倒和C++很像）即默认都是<code>final</code>的。除非用关键词<code>open</code>明确指明。同时，在一个final Class内部，是不允许有open成员的。看一个官网的例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span> &#123;&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span> &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>() : Base() &#123;</span><br><span class="line">  <span class="comment">//因为和父类v方法签名相同，所以必须明确指明是重写父类方法，否则编译不过</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span> &#123;&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//因为和父类nv方法签名相同，所以要么修改方法签名，要么把父类nv方法声明为open，且这里明确指明是重写父类方法。</span></span><br><span class="line">  <span class="comment">//fun nv() &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/24/Android中测量Text的宽度和高度/" itemprop="url">
                  Android中测量Text的宽度和高度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-24T22:38:18+08:00" content="2016-04-24">
              2016-04-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/24/Android中测量Text的宽度和高度/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/24/Android中测量Text的宽度和高度/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/24/Android中测量Text的宽度和高度/" class="leancloud_visitors" data-flag-title="Android中测量Text的宽度和高度">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android中，在自定义View中通过<code>Canvas</code>绘制文字时，经常需要测量文字的宽度和高度。这里记录下几种比较常用的方法，仅作备忘。</p>
<h4 id="1-Paint-measureText-（测量文本的宽度）"><a href="#1-Paint-measureText-（测量文本的宽度）" class="headerlink" title="1. Paint.measureText  （测量文本的宽度）"></a>1. Paint.measureText  （测量文本的宽度）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">paint.setTextSize(size);</span><br><span class="line"><span class="keyword">float</span> strWidth = paint.measureText(str);</span><br></pre></td></tr></table></figure>
<h4 id="2-Paint-getTextBounds-获得文字所在矩形区域，可以得到宽高"><a href="#2-Paint-getTextBounds-获得文字所在矩形区域，可以得到宽高" class="headerlink" title="2. Paint.getTextBounds (获得文字所在矩形区域，可以得到宽高)"></a>2. Paint.getTextBounds (获得文字所在矩形区域，可以得到宽高)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">Rect rect = <span class="keyword">new</span> Rect();  </span><br><span class="line">paint.getTextBounds(str, <span class="number">0</span>, str.length(), rect);  </span><br><span class="line"><span class="keyword">int</span> w = rect.width();  </span><br><span class="line"><span class="keyword">int</span> h = rect.height();</span><br></pre></td></tr></table></figure>
<h4 id="3-Paint-getTextWidths-获得每个字符的宽度"><a href="#3-Paint-getTextWidths-获得每个字符的宽度" class="headerlink" title="3. Paint.getTextWidths(获得每个字符的宽度)"></a>3. Paint.getTextWidths(获得每个字符的宽度)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> width = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = str.length();  </span><br><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line"><span class="keyword">float</span>[] widths = <span class="keyword">new</span> <span class="keyword">float</span>[len];  </span><br><span class="line">paint.getTextWidths(str, widths);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">     width += widths[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-通过Paint-FontMetrics-or-Paint-FontMetricsInt来获取高度"><a href="#4-通过Paint-FontMetrics-or-Paint-FontMetricsInt来获取高度" class="headerlink" title="4. 通过Paint.FontMetrics or Paint.FontMetricsInt来获取高度"></a>4. 通过Paint.FontMetrics or Paint.FontMetricsInt来获取高度</h4><p>这两者的含义相同，只不过精度不同，一个float、一个int。关于<code>Paint.FontMetrics</code>，可以参考<a href="http://mikewang.blog.51cto.com/3826268/871765" target="_blank" rel="external">这里</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">paint.setTextSize(size);<span class="comment">//设置字体大小</span></span><br><span class="line">paint.setTypeface(Typeface.xx);<span class="comment">//设置字体</span></span><br><span class="line">FontMetrics fontMetrics = getFontMetrics();</span><br><span class="line"><span class="keyword">float</span> height1 = fontMetrics.descent - fontMetrics.ascent;</span><br><span class="line"><span class="keyword">float</span> height2 = fontMetrics.bottom - fontMetrics.top;</span><br></pre></td></tr></table></figure>
<p>这里获取的两个高度略有不同，height2的高度会略大于height1，这样在文本的顶部和底部就会有一些留白。具体使用哪个高度，要看具体需求了。</p>
<p>此外，还可以通过<code>Paint.getFontSpacing</code>和<code>Paint.getFontMetrics(null)</code>来获得高度，其实前者也是调用后者来实现的。这里的值和通过<code>fontMetrics.descent - fontMetrics.ascent</code>获得的大小是一致的。</p>
<h4 id="5-Layout-getDesiredWidth-获得宽度"><a href="#5-Layout-getDesiredWidth-获得宽度" class="headerlink" title="5. Layout.getDesiredWidth (获得宽度)"></a>5. Layout.getDesiredWidth (获得宽度)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TextPaint textPaint = <span class="keyword">new</span> TextPaint();</span><br><span class="line">paint.setTextSize(size);<span class="comment">//设置字体大小</span></span><br><span class="line">paint.setTypeface(Typeface.xx);<span class="comment">//设置字体</span></span><br><span class="line"><span class="keyword">float</span> width = Layout.getDesiredWidth(str,textPaint);</span><br></pre></td></tr></table></figure>
<hr>
<p>之前碰到一个问题，TextView在布局上占用的高度和属性textSize的大小不一样，要比textSize的值大一些（比如textSize=”12dp”，实际的高度大概有14-16dp），仔细看的话会发现文字的上方和下发留有空白。查了下文档，发现可以通过设置<code>android:includeFontPadding</code>来控制是否包含上下空白。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/Android动画框架一/" itemprop="url">
                  Android动画框架一
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T22:04:49+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/17/Android动画框架一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/17/Android动画框架一/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/17/Android动画框架一/" class="leancloud_visitors" data-flag-title="Android动画框架一">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近，抽空看了下Android中的常用动画使用方式和实现机制，现整理如下：</p>
<h2 id="Drawable-Animation-Frame-Animation"><a href="#Drawable-Animation-Frame-Animation" class="headerlink" title="Drawable Animation(Frame Animation)"></a>Drawable Animation(Frame Animation)</h2><p>帧动画，就是依次展示一系列Drawable，来模拟动画的效果，类似于GIF图片。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>帧动画的使用方式比较简单，可以通过XML资源文件或者Java Code来实现（对应于AnimationDrawable类）。</p>
<h4 id="XML资源文件-放在anim或者Drawable目录下都可以"><a href="#XML资源文件-放在anim或者Drawable目录下都可以" class="headerlink" title="XML资源文件 (放在anim或者Drawable目录下都可以)"></a>XML资源文件 (放在anim或者Drawable目录下都可以)</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">android:oneshot</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/one"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/two"</span> <span class="attr">android:duration</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/three"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中android:oneshot表示是否仅播放一次，android:drawable表示每一帧图片，android:duration表示对应Drawable展示的持续时间。</p>
<h4 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable anim = <span class="keyword">new</span> AnimationDrawable();</span><br><span class="line">anim.addFrame(getDrawable(R.drawable.one),<span class="number">100</span>);</span><br><span class="line">anim.addFrame(getDrawable(R.drawable.two),<span class="number">200</span>);</span><br><span class="line">anim.addFrame(getDrawable(R.drawable.three),<span class="number">300</span>);</span><br><span class="line"> <span class="comment">//Draw区域，必须指定</span></span><br><span class="line">anim.setBounds(Rect);</span><br></pre></td></tr></table></figure>
<p>习惯上，我们把AnimationDrawable设置为View的背景，接着我们可以在Java Code中获取AnimationDrawable对象，然后通过start和stop方法来控制动画的播放。</p>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>至于AnimationDrawable是如何实现动画的？我首先想到的是：通过Handler根据每帧图片的持续时间，循环发送Message，定期处理Message，取出不同帧的Drawable进行draw。</p>
<p>仔细看了下源码，基本逻辑很类似，方法调用栈可以概括为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start -&gt; run -&gt; nextFrame -&gt; setFrame -&gt; scheduleSelf(Drawable)</span><br></pre></td></tr></table></figure></p>
<p>scheduleSelf方法会调用Drawable的Callback.scheduleDrawable方法。然后就是寻找哪里设置了callback属性，我一开始一直在AnimationDrawable的继承体系中寻找，但是只在AnimationDrawable的父类DrawableContainer中找到了Drawable.Callback的实现，但是这里根本就没有消息处理逻辑。后来请教了董大师，原来是在View.setBackgroundDrawable的时候，为Drawable设置了Callback回调,View.scheduleDrawable的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleDrawable</span><span class="params">(Drawable who, Runnable what, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verifyDrawable(who) &amp;&amp; what != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> delay = when - SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123; <span class="comment">//通过垂直同步信号(Vsync)触发下一帧的绘制</span></span><br><span class="line">            mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(Choreographer.CALLBACK_ANIMATION, what, who,Choreographer.subtractFrameDelay(delay));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//通过Handler消息机制触发下一帧的绘制</span></span><br><span class="line">            ViewRootImpl.getRunQueue().postDelayed(what, delay);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简洁，优先选择通过垂直同步信号来处理下一帧的绘制，若mAttachInfo为null，再通过Handler消息机制实现下一帧的绘制。Vsync信号的处理是在<code>Choreographer</code>类中，而Choreographer则负责控制用户的input事件、View的绘制和动画等行为，后续我们会详细分析该类。</p>
<blockquote>
<p>Frame Animation的主要缺点是：需要准备每一帧的图片，内存占用较大；并且只能用作View的前景和背景图，局限性比较大。</p>
</blockquote>
<h2 id="Tween-Animation（View-Animation）"><a href="#Tween-Animation（View-Animation）" class="headerlink" title="Tween Animation（View Animation）"></a>Tween Animation（View Animation）</h2><p>Tween Animation具有3个基本属性：开始帧、结束帧和动画持续时间，系统会根据这3个属性，计算出中间帧，实现渐变的效果。Tween Animation只能作用在View元素上，对于普通的类对象无能为力。</p>
<h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>补间动画包括4种变换，如下所示，分别指出了XML资源文件中的标签和对应的Java类：<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/tween.png" width="620" height="250"><br>Tween Animation可以通过Xml资源文件来定义，也可以直接创建对应的对象来操作，这里以位移动画为例简单介绍其使用方式。</p>
<h4 id="XML资源文件（放在anim目录下）"><a href="#XML资源文件（放在anim目录下）" class="headerlink" title="XML资源文件（放在anim目录下）"></a>XML资源文件（放在anim目录下）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">translate</span> </span><br><span class="line">	  <span class="attr">android:fromXDelta</span>=<span class="string">"20"</span> </span><br><span class="line">	  <span class="attr">android:toXDelta</span>=<span class="string">"60"</span> </span><br><span class="line">	  <span class="attr">android:fromYDelta</span>=<span class="string">"20"</span> </span><br><span class="line">	  <span class="attr">android:toYDelta</span>=<span class="string">"100"</span> </span><br><span class="line">	  <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span><br><span class="line">	  <span class="attr">android:duration</span>=<span class="string">"1000"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，fromXDelta,fromYDelta表示动画开始时X,Y座标;toXDelta,toYDelta表示动画结束时X,Y的座标；android:fillAfter=”true”，表示这个动画执行完之后保持最后的状态；android:duration表示动画持续的时间。</p>
<p>然后就是加载资源文件，播放动画:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TranslateAnimation animation = AnimationUtils.loadAnimation(context,R.anim.XXX);</span><br><span class="line">view.startAnimation(animation);</span><br></pre></td></tr></table></figure></p>
<h4 id="Java-Code-1"><a href="#Java-Code-1" class="headerlink" title="Java Code"></a>Java Code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TranslateAnimation animation = <span class="keyword">new</span> TranslateAnimation(fromXDelta,toXDelta,fromYDelta,toYDelta);<span class="comment">//创建位移动画，指定开始和结束的位移位置。</span></span><br><span class="line">animation.setFillAfter(<span class="keyword">true</span>);<span class="comment">//表示这个动画执行完之后保持最后的状态</span></span><br><span class="line">animation.setDuration(<span class="number">1000</span>);<span class="comment">//动画持续时间</span></span><br><span class="line">view.startAnimation(animation);</span><br></pre></td></tr></table></figure>
<p>除了使用单一的动画外，我们还可以通过AnimationSet来组合多个动画，并且可以为不同动画设置不同的startOffset时间，以实现不同动画之间的先后顺序。</p>
<p>因为AnimationSet也是继承Animation，所以针对Animation的属性也可以添加到AnimationSet上，但是这些属性对于AnimationSet来说具有不同的含义：</p>
<blockquote>
<p>duration, repeatMode, fillBefore和fillAfter，这四个属性，AnimationSet会把它们Push给他的子元素，也就是具体的补间动画。</p>
<p>repeatCount, fillEnabled，AnimationSet将忽略这两个属性。</p>
<p>startOffset, shareInterpolator，AnimationSet可以识别这两个属性，startOffset表示动画开始的延迟时间，shareInterpolator表示是否所有的子元素同享相同的插值器（关于Interpolator，下面会进行详细介绍）</p>
</blockquote>
<p><strong>Tips</strong>:<em>在Android4.0之前只能通过Java Code设置上述属性，XML文件设置会被忽略</em>。</p>
<h3 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h3><p>关于Tween Animation的使用，网上的例子很多，这里不再赘述，下面来分析下Tween的实现机制。<br>首先从View.startAnimation(animation)入手，这里的代码很简单，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设定开始时间</span></span><br><span class="line">    animation.setStartTime(Animation.START_ON_FIRST_FRAME);</span><br><span class="line">    <span class="comment">//保存Animation到View的mCurrentAnimation属性中</span></span><br><span class="line">    setAnimation(animation);</span><br><span class="line">    <span class="comment">//通知父View清除相关的缓存</span></span><br><span class="line">    invalidateParentCaches();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);<span class="comment">//请求重绘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以得知，View仅仅保存了Tween Animation，然后请求View重绘来实现动画。<br>既然Tween Animation动画是通过View重绘来实现的，那么我们简单了解下View的绘制流程，可以参考View.draw方法，基本包括6步：</p>
<ol>
<li>Draw the background，通过View.drawBackground方法来实现</li>
<li>If necessary, save the canvas’ layers to prepare for fading,如果需要，保存画布（canvas）的层为淡入或淡出做准备</li>
<li>draw the content，通过View.onDraw方法来实现，一般我们实现自己的View，就是通过该方法来操作，获得Canvas后，可以draw任何view，实现个性化的定制。</li>
<li>draw the children，通过View.dispatchDraw方法来实现，ViewGroup都会实现该方法，来绘制自己的孩子，这里也是实现Tween Animation的关键。参看 ViewGroup的代码，可知调用过程为：<code>dispatchDraw-&gt;drawChild-&gt;child.draw(canvas,parent,drawingTime)-&gt;child.draw(canvas)</code> ，这样的调用过程可以保证每个子View的draw函数都被调用，通过这种递归，从而让整个View树中的所有View的内容都得到绘制。<strong><em> 在调用每个子View的draw函数之前，View的绘制位置是Canvas通过translate函数来进行切换的，坐标原点切换到了每个子View的左上角窗口中的所有View 共用一个Canvas对象 </em></strong>。</li>
<li>If necessary, draw the fading edges and restore layers,如果需要，绘制淡入淡出相关的内容并恢复保存的画布所在层（layer）</li>
<li>draw decorations (scrollbars)，通过View.onDrawScrollBars方法来实现，绘制滚动条的操作就是在这里实现的。</li>
</ol>
<p>既然View的绘制离不开这几步操作，那么就需要看看具体哪一步操作完成了Tween Animation的绘制，仔细分析了各部分代码后，发现了补间动画的基本绘制流程。</p>
<p>首先，从ViewGroup.dispatchDraw方法开始，该方法会绘制每一个Child，即进入到ViewGroup.drawChild方法中，然后会调用View.draw(Canvas canvas, ViewGroup parent, long drawingTime)方法绘制具体的子View，这里就是实现Tween Animation的地方。极度精简后的关键代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取和每个子View绑定的Animation。</span></span><br><span class="line"><span class="keyword">final</span> Animation a = getAnimation();</span><br><span class="line"><span class="comment">//这个方法实现具体的动画操作，会调用到每个XXXAnimation子类的applyTransformation方法，applyTransformation方法会把每个动画帧对View的转换保存在Transformation类的Matrix和Alpha属性中，下面会详细分析该方法的实现，这里我们仅需要明确，此方法会把动画的转换保存在了Transformation中就可以了。</span></span><br><span class="line">more = drawAnimation(parent, drawingTime, a, scalingRequired);</span><br><span class="line"><span class="comment">//transformToApply就是保存具体动画帧的转换信息类。</span></span><br><span class="line">transformToApply = parent.getChildTransformation();</span><br><span class="line"><span class="comment">//这里主要是进行坐标系的转换，mLeft和mTop就是该子View在父ViewGroup中的位置，在Onlayout方法中指定，这里会把坐标系从父ViewGroup的左上角移动到子View的左上角，这点非常重要，重绘动画发生在子View自己的坐标系中，即子View的左上角是坐标原点。</span></span><br><span class="line"><span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">    canvas.translate(mLeft - sx, mTop - sy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!usingRenderNodeProperties) &#123;</span><br><span class="line">            canvas.translate(mLeft, mTop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// Undo the scroll translation, apply the transformation matrix,then redo the scroll translate to get the correct result.</span></span><br><span class="line">    canvas.translate(-transX, -transY);<span class="comment">//撤销滚动距离</span></span><br><span class="line">    <span class="comment">//把XXXAnimation所做的matrix改变，添加到当前Canvas Matrix上。因为每次重绘时drawingTime都不一样，所以每次的Matrix都不同，所以就实现了动画效果。</span></span><br><span class="line">canvas.concat(transformToApply.getMatrix());</span><br><span class="line">    canvas.translate(transX, transY);<span class="comment">//重做滚动</span></span><br><span class="line">    <span class="comment">//实现透明度渐变的动画           </span></span><br><span class="line">    <span class="keyword">float</span> transformAlpha = transformToApply.getAlpha();</span><br><span class="line">    alpha *= transformAlpha;</span><br></pre></td></tr></table></figure></p>
<p>上面只是实现了对Canvas的转换，下面还会通过draw(Canvas canvas)方法实现子View的具体绘制，此处不再赘述，可以参考View的绘制流程。</p>
<p>上面是Tween Animation的大体绘制流程，但是貌似还没有和我们的XXXAnimation相关联起来，下面我们再来分析下drawAnimation方法，就会涉及到具体Animation了,关键代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从父ViewGroup中取得变换（平移、旋转或缩放等）信息类Transformation，它包含了一个矩阵Matrix和alpha值，Matrix就是图形转换矩阵。</span></span><br><span class="line"><span class="keyword">final</span> Transformation t = parent.getChildTransformation();</span><br><span class="line"><span class="comment">//drawingTime表示当前的绘制时间。more表示动画是否结束，若动画没有结束就返回true，直到动画结束返回false，这里的参数a就是从子View中取出的具体XXXAnimation了。XXXAnimation对View所做的转换，会保存在Transformation中的Matrix矩阵和alpha属性中，供上面的draw方法来实现对Canvas的转换。</span></span><br><span class="line"><span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line">该方法剩余的代码，会判断动画是否结束，若没有结束，则会调用invalidate来不断的重绘，直到动画结束，此处不再赘述。</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们继续看下具体实现动画变换的getTransformation方法，关键代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取该动画的延迟执行时间</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> startOffset = getStartOffset();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> duration = mDuration;</span><br><span class="line"><span class="keyword">float</span> normalizedTime;</span><br><span class="line"><span class="keyword">if</span> (duration != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//根据当前时间、动画持续时间，计算出当前动画的时间进度百分比，介于0和1之间</span></span><br><span class="line">    normalizedTime = ((<span class="keyword">float</span>) (currentTime - (mStartTime + startOffset))) / (<span class="keyword">float</span>) duration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// time is a step-change with a zero duration，特殊情况，动画直接结束。</span></span><br><span class="line">    normalizedTime = currentTime &lt; mStartTime ? <span class="number">0.0f</span> : <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断动画是否结束。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> expired = normalizedTime &gt;= <span class="number">1.0f</span>;</span><br><span class="line">    mMore = !expired;</span><br><span class="line">    <span class="keyword">if</span> ((normalizedTime &gt;= <span class="number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="number">1.0f</span> || mFillAfter)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">            <span class="comment">//通知回调，动画开始执行</span></span><br><span class="line">            fireAnimationStart();</span><br><span class="line">            mStarted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (USE_CLOSEGUARD) &#123;</span><br><span class="line">                guard.open(<span class="string">"cancel or detach or getTransformation"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//获得插值器，插值器的作用就是根据上面获得的时间进度百分比，计算出动画的当前进度，以此来实现加速、减速等动画效果，可以用函数f(t)=t来表示，其中t表示时间进度，f(t)表示真实的动画进度，关于插值器，下面会进行详细的介绍。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</span><br><span class="line">    <span class="comment">//applyTransformation是具体的动画实现过程，由每个XXXAnimation子类负责实现。简单来说，就是传入动画进度，然后该函数会根据动画进度，填充具体的转换矩阵。不同时刻对应不同的转换矩阵，通过该转换矩阵，就可以绘制出变换后的子View，从而实现动画效果。</span></span><br><span class="line">    applyTransformation(interpolatedTime,outTransformation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若动画过期了，即结束了</span></span><br><span class="line">    <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">        <span class="comment">//若动画已经执行完了所有的重复行为，则通知回调，动画结束了.否则，继续重复动画行为，并通知回调，repetat开始了。</span></span><br><span class="line">        <span class="keyword">if</span> (mRepeatCount == mRepeated) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mEnded) &#123;</span><br><span class="line">                mEnded = <span class="keyword">true</span>;</span><br><span class="line">                guard.close();</span><br><span class="line">                fireAnimationEnd();<span class="comment">//end回调</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (mRepeatCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mRepeated++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123; <span class="comment">//这里主要处理是反向重复还是正向重复。</span></span><br><span class="line">                mCycleFlip = !mCycleFlip;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            mStartTime = -<span class="number">1</span>;</span><br><span class="line">            mMore = <span class="keyword">true</span>;<span class="comment">//若重复还没有执行完，则重新对mMore赋值。</span></span><br><span class="line"></span><br><span class="line">            fireAnimationRepeat();<span class="comment">//repeat回调</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> mMore;</span><br></pre></td></tr></table></figure></p>
<p>上面分析了getTransformation方法的主要流程，可知具体的动画变换是在applyTransformation方法中执行的，而该方法在Animation类中没有具体实现，需要在子类中实现，也就是说自定义动画需要实现applyTransformation函数。我们可以看下TranslateAnimation的applyTransformation方法实现，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dx = mFromXDelta;<span class="comment">//起始的X坐标位移</span></span><br><span class="line">    <span class="keyword">float</span> dy = mFromYDelta;<span class="comment">//起始的Y坐标位移</span></span><br><span class="line">    <span class="keyword">if</span> (mFromXDelta != mToXDelta) &#123;</span><br><span class="line">        <span class="comment">//根据动画进度，计算出X坐标上具体的位移量</span></span><br><span class="line">        dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFromYDelta != mToYDelta) &#123;</span><br><span class="line">        <span class="comment">//根据动画进度，计算出Y坐标上具体的位移量</span></span><br><span class="line">        dy = mFromYDelta + ((mToYDelta - mFromYDelta) * interpolatedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过图形变换矩阵来实现具体的位移。</span></span><br><span class="line">    t.getMatrix().setTranslate(dx, dy);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码分析了位移动画的具体实现，其他XXXAnimation的实现非常类似，此处不再赘述。</p>
<h3 id="Interpolator"><a href="#Interpolator" class="headerlink" title="Interpolator"></a>Interpolator</h3><p>下面看下插值器（Interpolator）,插值器的基类是TimeInterpolator，它只有一个方法getInterpolation(float input);其中参数，input表示动画的时间进度，屏蔽了duration的差异，介于0和1之间。返回值则表示真实的动画进度，可以用函数f(t)=t来表示，其中t表示时间进度，f(t)表示真实的动画进度。系统提供了很多插值器，我们也可以根据自己的需求来实现自己的插值器。下面分别是线性、加速和减速插值器,可以直观感受下：</p>
<ul>
<li>线性插值器，插值函数为f(t) = t;<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E5%99%A8.gif" alt="线性插值器"></li>
<li>加速插值器,默认情况下，插值函数为f(t)=t*t;<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/%E5%8A%A0%E9%80%9F%E6%8F%92%E5%80%BC%E5%99%A8.gif" alt="加速插值器"></li>
<li>减速插值器,默认情况下，插值函数为f(t)=1 - (1 - t)*(1 - t);<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/%E5%87%8F%E9%80%9F%E6%8F%92%E5%80%BC%E5%99%A8.gif" alt="减速插值器"></li>
</ul>
<p>关于Tween Animation，到这里基本分析完了，我们简单总结下：</p>
<ol>
<li>Tween Animation不是通过子View来实现的，而是通过ParentView不断调整ChildView的画布坐标系来实现的，即改变的仅仅是子view的绘制位置。而子View的left、top、right和bottom属性都没有改变，即子View的Layout位置并没有发生改变，因此，<code>子View的Event接收区域也没有发生改变</code>。假设：子View的left和top属性都为100，然后有一个位移动画使该子View移动（50，50）,那么当动画发生时，父ViewGroup首先会把子 traslate(left,top)，然后随着不同的动画帧到来，再traslate(deltaX,deltaY)，那么动画结束时，该子View的最终位置就是（150,150）了，但它的left和top还是100.</li>
<li>如果要实现自己的Tween Animation，可以重写Animation.applyTransformation()方法来实现，如果要实现不同的动画变换速率，可以重写TimeInterpolator.getInterpolation(float input)方法来实现。</li>
</ol>
<hr>
<p>其实，这里还有一个疑问，Tween Animation的重绘频率是多少？简单，自己重写Animation.applyTransformation方法打印出时间间隔就OK了，打印出的log如下所示：<br><img src="http://7xs2qy.com1.z0.glb.clouddn.com/animation_log.png" width="400"></p>
<p>由log可知，重绘的频率基本在16ms左右，这和Android系统的Vsync信号正好吻合。上面学习Drawable Animation时，我们提到了Choreographer类，该类负责控制用户的input事件、View的绘制和动画等行为，其实我们调用invalidate方法时，View不会立即重绘，而是等到Vsync信号到来时，由Choreographer驱动View绘制事件来实现View的绘制。而Vsync信号一般是60HZ，差不多是16ms一次信号，所以才显示出Tween Animation的绘制时间间隔为16ms左右。关于Choreographer类，我们在学习属性动画时，再详细的分析。</p>
<blockquote>
<p>Tween Animation的主要缺点：只能针对View体系作变换；只支持透明度、位移、缩放和旋转等动画；改变的只是绘制位置，View的真实属性并没有发生改变，处理Event事件的区域也没有发生变化；只支持动画的并行组合，不支持串行动画。</p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/Kotlin基本语法1/" itemprop="url">
                  Kotlin基本语法1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-17T21:37:06+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/17/Kotlin基本语法1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/17/Kotlin基本语法1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/17/Kotlin基本语法1/" class="leancloud_visitors" data-flag-title="Kotlin基本语法1">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Kotlin是一门与Swift类似的静态类型JVM语言，由JetBrains设计开发并开源，号称“Android世界的Swift”。最近花时间看了下这门语言，整理了一些和Java区别比较大的方面，仅作备忘（这里仅是一部分）。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><p>在Kotlin 中，if是一个带有返回值的表达式（也可以是一般性语句）。因此，在Kotlin中没有三元操作符(condition ? then : else)，因为<code>if表达式</code>就能胜任这项工作。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> a</span> = <span class="number">1</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if作为表达式，此时必须有else分支</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> max</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">//if作为表达式，此时必须有else分支（此时分支是代码块，且代码块的最后一个表达式的值是当前代码块的值）</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> min</span> = <span class="keyword">if</span> (a &gt; b) &#123; </span><br><span class="line">    print(<span class="string">"Choose a"</span>) </span><br><span class="line">    b </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    print(<span class="string">"Choose b"</span>) </span><br><span class="line">    a </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>作为表达式时，一般是将<code>if表达式</code>（的值）赋值为变量，或者在函数中return<code>if表达式</code>（的值）。在这种情况下，<code>if表达式</code>必须包含else分支。</p>
<p>除了作为表达式之外，<code>if</code>也可以实现一般性语句，此时则不必包含else分支。<br>例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int, b: Int</span>)</span>: <span class="keyword">Int</span> &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        println(<span class="string">"a"</span>)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h3><p>在Kotlin中，<code>when</code>是switch的替代品。<code>when</code>既可以作为表达式，也可以是一般性语句。<br>作为<code>when</code>表达式时，else分支是不可缺少的（除非编译器检测到前面的条件分支覆盖了所有的情况）。同时，最终匹配的条件分支的值就是整个<code>when表达式</code>的值。（和if表达式一样，when表达式中的分支也可以是代码块，代码块的值则是最后一条表达式的值）。<br>作为一般性语句时，则忽略每个分支的值。</p>
<p><code>when表达式</code>中比较多变是分支条件（branch condition），可以是普通字面量、常量、表达式、范围判断以及类型判断等。例如:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> x</span> = <span class="number">4</span></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="comment">//字面量</span></span><br><span class="line">    <span class="number">3</span> -&gt; println(<span class="string">"常量"</span>)</span><br><span class="line">    <span class="comment">//表达式</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="number">2</span> <span class="keyword">else</span> <span class="number">-1</span> -&gt; println(<span class="string">"表达式"</span>)</span><br><span class="line">    <span class="comment">//范围匹配</span></span><br><span class="line">    !<span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; println(<span class="string">"范围匹配"</span>)</span><br><span class="line">    <span class="comment">//类型判断</span></span><br><span class="line">    <span class="keyword">is</span> <span class="keyword">Int</span> -&gt; println(<span class="string">"类型判断"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">"else"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，<code>when</code>能够取代<code>if-else if</code>链。例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">  a &gt; b -&gt; print(<span class="string">"a &gt; b"</span>)</span><br><span class="line">  a <span class="type">&lt; b -&gt;</span> print(<span class="string">"a &lt; b"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"a == b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，没有when参数，若分支条件为true，则匹配成功。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for操作符可以对任何提供迭代器的对象进行遍历（这点和Java类似）。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection)</span><br><span class="line">  println(item)</span><br></pre></td></tr></table></figure>
<p>但是对数组的遍历，会被编译器优化成基于索引值来遍历，而不会创建迭代器对象。<br>当然，我们也可以显示的通过索引值来遍历一个数组，例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)</span><br><span class="line">  println(array[i])</span><br></pre></td></tr></table></figure></p>
<p>另外，针对数组，还有更方便的遍历方式，例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> array</span> = arrayOf(<span class="string">"leon"</span>, <span class="string">"lt"</span>, <span class="string">"zh"</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"the element at $index is $value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><code>while</code>和 <code>do..while</code>的使用方式和Java中相同，例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> a</span> = <span class="number">0</span>;</span><br><span class="line">    println(<span class="string">"a = $a"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> (a <span class="type">&lt; 0)//注意，这里变量a可以被访问，这点和java当中不同。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Null安全性"><a href="#Null安全性" class="headerlink" title="Null安全性"></a>Null安全性</h2><p>在Java中，出现频率最高的运行时异常应该就是<code>NullPointerException</code>。Kotlin致力于消除空指针异常，Kotlin类型系统将引用（reference）分为可空和不可空。</p>
<p>默认情况下，变量是不可空类型，例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span>: String = <span class="string">"abc"</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">// compilation error</span></span><br></pre></td></tr></table></figure></p>
<p>但是，我们可以通过在类型后面添加<code>?</code>，来明确声明一个可空的变量。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时变量的类型为String?，和String是不同，不可直接赋值</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span>: String? = <span class="string">"abc"</span> </span><br><span class="line">b = <span class="literal">null</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">//因为变量b可能为null，所以下面的语句是编译不过的</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> l</span> = b.length <span class="comment">//error: variable 'b' can be null</span></span><br></pre></td></tr></table></figure></p>
<p>针对可空类型的变量，有两种方式来访问他们的属性和方法。</p>
<ol>
<li><p>明确地检测变量是否为Null</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> str</span>: String? = <span class="string">"abc"</span></span><br><span class="line">println(str.length) <span class="comment">//编译不通过，str可能为Null</span></span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//编译器检测到进行了非空检测，所以允许直接访问字符串的legth属性</span></span><br><span class="line">    println(str.length)</span><br><span class="line">&#125;</span><br><span class="line">println(str.length)<span class="comment">//编译不通过，str可能为Null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>?.</code>安全的调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> str</span>: String? = <span class="string">"abc"</span></span><br><span class="line"><span class="comment">//如果str不为Null，就会返回字符串的长度，否则返回null。变量len的类型是Int?</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> len</span> = str?.length</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="针对可空变量的特殊操作符"><a href="#针对可空变量的特殊操作符" class="headerlink" title="针对可空变量的特殊操作符"></a>针对可空变量的特殊操作符</h3><h4 id="操作符"><a href="#操作符" class="headerlink" title="?:操作符"></a><code>?:</code>操作符</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> str</span>: String? = <span class="string">"abc"</span></span><br><span class="line"><span class="comment">//str不为Null，则返回字符串长度，否则返回-1</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> len</span> = str?.length ?: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>假如<code>?:</code>操作符左边的表达式是非空的，那么<code>?:</code>操作符就返回左边表达式的值, 否则就返回右边的内容。并且，仅在左侧值为Null时，右侧表达式才会进行计算。</p>
<p>因为<code>throw</code>和<code>return</code>也是表达式，所以都可以使用在<code>?:</code>操作符的右侧，这在函数头部检查参数的合法性时，很有用。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span>: String? &#123;</span></span><br><span class="line">  <span class="comment">//若node.getParent()为Null，那么函数直接返回Null</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> parent</span> = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">//若node.getName()为Null，那么函数直接抛出异常</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> name</span> = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="操作符-1"><a href="#操作符-1" class="headerlink" title="!!操作符"></a><code>!!</code>操作符</h4><p>如果你想要强制访问在一个可空变量的属性，那可以通过<code>!!</code>操作符来操作。但是这可能导致空指针异常，请谨慎使用！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val str: String? = &quot;abc&quot;</span><br><span class="line">//str不为Null，则返回字符串长度，否则抛出KotlinNullPointerException异常</span><br><span class="line">val len = str!!.length</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>和Java中一样，kotlin中的字符串也是不可变的，但是我们可以直接通过索引运算符<code>[]</code>来访问字符串中的字符。</p>
<p>在kotlin中，支持两种类型的字符串字面值：</p>
<ol>
<li><p><code>转义字符串</code><br><code>转义字符串</code>支持转义字符，类似于Java中的字符串</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> str</span> = <span class="string">"Hello, world!\nLeon"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>原生字符串</code><br><code>原生字符串</code>使用3个双引号<code>&quot;&quot;&quot;</code>括起来，内部不支持转义字符<code>\</code>，但是可以包含多行和任意字符。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val text = """</span><br><span class="line">  for (c in "foo")</span><br><span class="line">    print(c)</span><br><span class="line">"""</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>kotlin中的两种字符串字面量都可以包含模板表达式，这里会计算出模板表达式的值，并插入在对应的字符串索引处（这对于在Java中拼接字符串来说简直是福音啊）。所谓模板表达式就是以<code>$</code>开头的表达式，包含两种形式：</p>
<ul>
<li><p><code>$</code> + 简单名称</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> i</span> = <span class="number">10</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> s</span> = <span class="string">"i = $i"</span> <span class="comment">// s为"i = 10"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$</code> + {表达式}</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> str</span> = <span class="string">"abc"</span></span><br><span class="line"><span class="comment">//result为 "abc.length is 3"</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> result</span> = <span class="string">"$str.length is $&#123;str.length&#125;"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此外，因为原生字符串不支持转义字符<code>\</code>，因此可以使用<code>${&#39;$&#39;}</code>在原生字符串中表示<code>$</code>。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在kotlin中，定义函数使用<code>fun</code>关键词。函数的定义可以概括如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> 函数名（参数名 : 参数类型 = 默认参数 , ...） : 返回类型 &#123; 代码块 &#125;</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> 函数名（参数名 : 参数类型 = 默认参数 , ...） : [返回类型] = 单个表达式</span></span><br></pre></td></tr></table></figure></p>
<p>函数体可以是代码块，此时必须显示指定函数返回值，除非返回类型为<code>Unit</code>）；也可以是单个表达式，此时可以省略函数返回值，kotlin可以推断出返回值。<br>函数参数可以指定默认值，对于这种参数，调用时可以省略该参数值。（很像C++语法）</p>
<p>根据函数的特点，可以分为以下几类：</p>
<ul>
<li><p>顶级函数<br>定义在文件顶级作用域，对于顶级函数，不必创建对象就可以直接调用。</p>
</li>
<li><p>成员函数<br>定义在类内部，即成员函数。相当于Java中的类实例函数。</p>
</li>
<li><p>扩展函数<br>很有用的功能，可以对已有的类添加扩展函数。</p>
</li>
<li><p>局部函数<br>定义在函数中的函数，局部函数可以访问外部函数的局部变量，即闭包</p>
</li>
<li><p>高阶函数<br>可以把函数作为参数，或者把函数作为返回值的函数。</p>
</li>
<li><p>内联函数<br>编译时内联函数会被内联到代码调用处，减少了函数调用的开销。</p>
</li>
</ul>
<h2 id="函数字面量-Function-Literal"><a href="#函数字面量-Function-Literal" class="headerlink" title="函数字面量 (Function Literal)"></a>函数字面量 (Function Literal)</h2><p>未被声明，直接作为表达式被传递的函数称为函数字面量，包括Lambda表达式和匿名函数。函数字面量经常作为参数传递给高阶函数使用。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Kotlin中，Lambda表达式的格式如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数 : [参数类型] -&gt; 代码块&#125;</span><br></pre></td></tr></table></figure></p>
<p>若高阶函数的最后一个参数是函数，那么在使用Lambda表达式作为参数值时，可以把Lambda表达式放在参数括号外面（若高阶函数只有一个函数参数，那参数括号就可以完全省略了）。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高阶函数1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lambda1</span><span class="params">(a: <span class="type">Int, hanshu: (Int</span>)</span> -&gt; <span class="keyword">Int</span>) &#123;</span></span><br><span class="line">    println(hanshu(a))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用高阶函数1</span></span><br><span class="line">lambda1(<span class="number">1</span>) &#123;args -&gt; args * <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如Lambda表达式只有一个参数，则可以使用默认的参数it</span></span><br><span class="line">lambda1(<span class="number">1</span>) &#123;it * <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高阶函数2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lambda2</span><span class="params">(hanshu: <span class="type">(</span>)</span> -&gt; <span class="keyword">Int</span>) &#123;</span></span><br><span class="line">    println(hanshu())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用高阶函数2</span></span><br><span class="line">lambda2 &#123; <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>(Int) -&gt; Int</code>表示函数类型，即一个接收Int类型参数，返回Int类型值的函数。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>使用Lambda表达式作为高阶函数参数值存在一个缺点：无法指定函数返回值。虽然多数情况下，编译器可以推断出返回值。但是特殊情况下，若一定需要指定返回值，那么就可以使用匿名函数作为高阶函数参数值。</p>
<p>匿名函数和普通函数只有2点不同</p>
<ol>
<li>匿名函数没有函数名（废话）</li>
<li>参数类型可以省略（在可以被推断出来的情况下）</li>
</ol>
<p>当把匿名函数作为高阶函数的参数时，不能写在高阶函数参数括号外面（即：此规则只适用于Lambda表达式）。<br>因此，针对上面高阶函数的调用，可以写成这样：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lambda1(<span class="number">3</span>, <span class="function"><span class="title">fun</span><span class="params">(a)</span>: <span class="keyword">Int</span> &#123;</span></span><br><span class="line">       <span class="keyword">return</span> a * <span class="number">2</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></p>
<p>除此之外，Lambda表达式和匿名函数在处理<code>return</code>语句时，也存在差异。<br>在Kotlin中，我们能够通过<code>return</code>语句，直接从命名函数或者匿名函数退出。因此，如果想从Lambda表达式中退出，必须使用<code>带标签的return</code>。例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">innerFun</span><span class="params">(hanshu: <span class="type">(</span>)</span> -&gt; <span class="keyword">Int</span>) &#123;</span></span><br><span class="line">    println(<span class="string">"innerFun"</span>)</span><br><span class="line">    hanshu()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span>: <span class="keyword">Int</span> &#123;</span></span><br><span class="line">    innerFun &#123; <span class="keyword">return</span>@innerFun <span class="number">3</span> &#125;</span><br><span class="line">    println(<span class="string">"foo fun"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">innerFun</span><br><span class="line">foo <span class="function"><span class="keyword">fun</span></span></span><br></pre></td></tr></table></figure></p>
<p>那么若我们想从当前函数退出那（即foo函数），理论上应该去掉标签就OK了，但是Kotlin却不允许这么做，这很容易导致误解。<br>除非调用Lambda表达式的函数是内联函数，即innerFun是内联函数，此时return语句会被内联到foo函数，那么return语句直接从foo函数退出，也就很好理解了。例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">innerFun</span><span class="params">(hanshu: <span class="type">(</span>)</span> -&gt; <span class="keyword">Int</span>) &#123;</span></span><br><span class="line">    println(<span class="string">"innerFun"</span>)</span><br><span class="line">    hanshu()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span>: <span class="keyword">Int</span> &#123;</span></span><br><span class="line">    innerFun &#123; <span class="keyword">return</span>  <span class="number">3</span> &#125;</span><br><span class="line">    println(<span class="string">"foo fun"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">innerFun</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)。<br>在kotlin中，函数字面量（Lambda表达式和匿名函数）能够访问它的闭包。并且可以修改闭包中的变量，这点和java不同。例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> count</span> = <span class="number">0</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> ints</span> = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">ints.filter &#123; it &gt; <span class="number">0</span> &#125;.forEach &#123;</span><br><span class="line">    count += it</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"count = $count"</span>)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">count = <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h3 id="指定接收者的函数字面量（Function-Literals-with-Receiver）"><a href="#指定接收者的函数字面量（Function-Literals-with-Receiver）" class="headerlink" title="指定接收者的函数字面量（Function Literals with Receiver）"></a>指定接收者的函数字面量（Function Literals with Receiver）</h3><p>指定接收者的函数字面量和类的扩展函数很像，在函数字面量函数体内，可以直接访问Receiver的方法。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数sum的类型就是一种Function Literals with Receiver</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(str: <span class="type">String, sum: String.(String</span>)</span> -&gt; <span class="keyword">Unit</span>) &#123;</span></span><br><span class="line">    str.sum(<span class="string">"World"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以Lambda表达式作为参数，此时Receiver是由编辑器推断出来的</span></span><br><span class="line">hello(<span class="string">"Hello"</span>) &#123;</span><br><span class="line">    <span class="comment">//this表示接收者字符串，即"Hello",it表示参数，即"World"</span></span><br><span class="line">    println(this + it + <span class="string">" length = "</span> + (this.length + it.length))</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//以匿名函数作为参数，此时Receiver是由匿名函数明确指定的   </span></span><br><span class="line">hello(<span class="string">"Hello"</span>, <span class="function"><span class="keyword">fun</span> String.<span class="params">(it: <span class="type">String</span>)</span> &#123;</span></span><br><span class="line">    <span class="comment">//this表示接收者字符串，即"Hello",it表示参数，即"World"</span></span><br><span class="line">    println(this + it + <span class="string">" length = "</span> + (this.length + it.length))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">HelloWorld length = <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>上述<code>String.(String) -&gt; Unit</code>就是指定接收者的函数字面量的类型，表示只有字符串类型对象才可以调用这个以字符串为参数且无返回值的函数。</p>
<hr>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ol>
<li><a href="http://kotlinlang.org/" target="_blank" rel="external">kotlin官网</a></li>
<li><a href="https://github.com/cctanfujun/kotlin-web-site-cn" target="_blank" rel="external">kotlin官网中文版</a></li>
<li><a href="https://github.com/wangjiegulu/kotlin-for-android-developers-zh/blob/master/SUMMARY.md" target="_blank" rel="external">kotlin-for-android-developers-zh</a></li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/06/Hexo/" itemprop="url">
                  Hexo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-06T22:32:31+08:00" content="2016-04-06">
              2016-04-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/06/Hexo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/06/Hexo/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
     
         
        
          <span id="/2016/04/06/Hexo/" class="leancloud_visitors" data-flag-title="Hexo">
             &nbsp; | &nbsp;
                 <span class="post-meta-item-icon">
                   <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数 </span>
                  <span class="leancloud-visitors-count"></span>                                                                                                 
                </span>
         
 
      </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xs2qy.com1.z0.glb.clouddn.com/Android.png"
               alt="leon" />
          <p class="site-author-name" itemprop="name">leon</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ltlovezh" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1758856740/profile?topnav=1&wvr=6&is_all=1" target="_blank">
                  
                    <i class="fa fa-weibo"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/li-tao-81-84" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/63230484/" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  douban
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
            <div class="links-of-blogroll-title">技术博文</div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.androidweekly.cn" target="_blank">Android开发技术周报</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://droidyue.com" target="_blank">技术小黑屋</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.importnew.com" target="_blank">ImportNew</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/luoshengyang" target="_blank">老罗</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/innost" target="_blank">邓凡平</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" target="_blank">郭霖</a>
                </li>
              
            </ul>
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


&nbsp;&nbsp;|&nbsp;&nbsp;

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
&nbsp;
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ltlovezh"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("O6G37ih07JTb0JMO5fLi1AO4-gzGzoHsz", "JQOTur9Y1GDaPWghewFrdFA1");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
</body>
</html>
